<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv='X-UA-Compatible' content='IE=edge;chrome=1' />
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <meta name="google-site-verification" content="qjqVOvRhHfsuDbLOvaAnj2mkUZJ9Xwzg84TMVXduvUc" />

    <meta charset="UTF-8">
    <title>Hyperloop</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>

    <link href="/stylesheets/base.css" rel="stylesheet" />
    <link href="/stylesheets/normalize.css" rel="stylesheet" />
    <link href="/stylesheets/stylesheet.css" rel="stylesheet" />
    <link href="/stylesheets/github-light.css" rel="stylesheet" />

    <title>Reactrb</title>
    <link rel="alternate" type="application/atom+xml" title="Atom Feed" href="/feed.xml" />

    <!-- Favicons -->
    <link rel="apple-touch-icon" sizes="57x57" href="/images/apple-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="60x60" href="/images/apple-icon-60x60.png">
    <link rel="apple-touch-icon" sizes="72x72" href="/images/apple-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="/images/apple-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="/images/apple-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="/images/apple-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="/images/apple-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="/images/apple-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-icon-180x180.png">
    <link rel="icon" type="image/png" sizes="192x192"  href="/images/android-icon-192x192.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="96x96" href="/images/favicon-96x96.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
    <link rel="manifest" href="/manifest.json">
    <meta name="msapplication-TileColor" content="#ffffff">
    <meta name="msapplication-TileImage" content="/images/ms-icon-144x144.png">
    <meta name="theme-color" content="#ffffff">

  </head>

  <body>
      <section class="page-header">
        <img src="/images/hyperloop_white.svg" width="200" alt="Hyperloop white" />
        <h1 class="project-name">
          <a href="/" class="btn-logo">Hyperloop</a>
        </h1>
        <h2 class="project-tagline">THE MISSING RUBY FRONT-END LIBRARY</h2>
        
        <a href="/get_started" class="btn">Get Started</a>
<a href="/tutorials" class="btn">Tutorials</a>
<a href="/installation" class="btn">Installation</a>
<a href="/gems" class="btn">Gems</a>
<a href="https://github.com/reactrb" class="btn">Github</a>
<a href="/tools" class="btn">Tooling</a>
<a href="/docs/dsl_overview" class="btn">Docs</a>
<a href="/support" class="btn">Support</a>
<a href="/blog" class="btn">Blog</a>


      </section>

      <section class="main-nav">
          <a href="/gems/reactrb">Reactrb</a></br>
  <a href="/gems/reactrb-reactive-record">Reactive Record</a></br>
  <a href="/gems/reactrb-synchromesh">Synchromesh</a></br>
  <a href="/gems/reactrb-router">Router</a></br>
  <a href="/gems/reactrb-express">Reactrb Express</a></br>

      </section>

      <section class="main-content">
        <h1 id="hyperloop-reactive-record">Hyperloop Reactive Record</h1>

<p>Github: <a href="https://github.com/reactrb/reactive-record">Reactive Record</a></p>

<p>Reactive Record is a client-side representation of your Active Record models fully integrated with Reactrb. Reactive Record works perfectly with Synchromesh to magically synchronise server side data changes with any connected client. Writing simple code, without worrying about how data moves between one machine and another, and then seeing live updates in action is magical.</p>

<h4 id="reactive-record-gives-you-active-record-models-on-the-client-integrated-with-reactrb">Reactive Record gives you Active Record models on the client integrated with Reactrb.</h4>

<p>You do nothing to your current Active Record models except move them to the models/public directory (so they are compiled on the client as well as the server.)</p>

<ul>
<li>Fully integrated with <a href="https://github.com/reactrb/reactrb">Reactrb</a> (which is React with a beautiful Ruby DSL).</li>
<li>Paired with <a href="https://github.com/reactrb/synchromesh">Synchromesh</a> to magically push server-side data changes to all authorised clients displaying that data.</li>
<li>Takes advantage of React prerendering, and afterwards additional data is <em>lazy loaded</em> as it is needed by the client.</li>
<li>Supports full CRUD access using standard Active Record features, including associations, aggregations, and errors.</li>
<li>Uses model based authorization mechanism for security similar to <a href="http://www.hobocentral.net/manual/permissions">Hobo</a> or <a href="https://github.com/elabs/pundit">Pundit</a>.</li>
<li>Models and even methods within models can be selectively implemented server-side only.</li>
</ul>

<h2 id="installation">Installation</h2>

<p>Add this line to your application&rsquo;s Gemfile:
<code>ruby
gem &#39;reactive-record&#39;
</code>
And then execute:
<code>text
$ bundle install
</code>
Finally you need to add a line to your &lsquo;routes.rb&rsquo;:
<code>ruby
mount ReactiveRecord::Engine =&gt; &#39;/rr&#39;
</code></p>

<h3 id="models">Models</h3>

<p>Reactive Record creates a client side (JavaScript) representation of your Active Record models. This representation can be taken directly from your existing models or if you prefer you can maintain a seperate version of your models (a public version). In this example we will keep the models we want Reactive Record to see in  <code>models/public</code> and <code>require</code> this into <code>components.rb</code> so it is compiled to JavaScript and available to our client code..</p>

<p>Create a new folder:
<code>text
models/public
</code>
Then create <code>_react_public_models.rb</code> in your <code>models</code> folder:
&ldquo;`ruby</p>

<h1 id="models-reactpublic_models-rb">models/<em>react</em>public_models.rb</h1>

<p>require_tree &lsquo;./public&rsquo;
<code>
And then add a line to your `views/components.rb` file:
</code>ruby</p>

<h1 id="views-components-rb">views/components.rb</h1>

<p>require &lsquo;<em>react</em>public_models&rsquo;
&rdquo;<code>
And that is all the setup you need. Any Active Record models you place in the</code>models/public` folder will be avalable to you client-side Reactrb code as it they were on the client.</p>

<h2 id="usage">Usage</h2>

<p>Let&rsquo;s assume you have two Active Record models which we have placed in your <code>models/public</code> folder so they can be seen by Reactive Record:</p>
<pre class="highlight ruby"><code><span class="c1"># models/public/post.rb</span>
<span class="k">class</span> <span class="nc">Post</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">has_many</span> <span class="ss">:comments</span>
<span class="k">end</span>
</code></pre><pre class="highlight ruby"><code><span class="c1"># models/public/comments.rb</span>
<span class="k">class</span> <span class="nc">Comment</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">belongs_to</span> <span class="ss">:post</span>
<span class="k">end</span>
</code></pre>
<p>Note that Reactive Record is less permissive than Active Record so it is important that you explicitly define both ends of an association (<code>has_many</code> must always have an associated <code>belongs_to</code>).</p>

<p>Let&rsquo;s create a simple Reactrb component that renders a list of all posts and their associated comments:</p>
<pre class="highlight ruby"><code><span class="c1"># views/components/post_with_comments_list.rb</span>
<span class="k">class</span> <span class="nc">PostsWithCommentsList</span> <span class="o">&lt;</span> <span class="no">React</span><span class="o">::</span><span class="no">Component</span><span class="o">::</span><span class="no">Base</span>

  <span class="n">before_mount</span> <span class="k">do</span>
    <span class="vi">@posts</span> <span class="o">=</span> <span class="no">Post</span><span class="p">.</span><span class="nf">all</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">render</span>
    <span class="n">ul</span> <span class="k">do</span>
      <span class="vi">@posts</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">post</span><span class="o">|</span>
        <span class="n">li</span> <span class="p">{</span> <span class="n">post</span><span class="p">.</span><span class="nf">title</span> <span class="p">}</span>
        <span class="n">ul</span> <span class="k">do</span>
          <span class="n">post</span><span class="p">.</span><span class="nf">comments</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">comment</span><span class="o">|</span>
            <span class="n">li</span> <span class="p">{</span> <span class="n">comment</span><span class="p">.</span><span class="nf">body</span> <span class="p">}</span>
          <span class="k">end</span>
        <span class="k">end</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
<p>Note that with Reactive Record <code>@posts = Post.all</code> is set in <code>before_mount</code> whereas if you were using a a REST based <code>GET</code> you would have done so in <code>after_mount</code>. Setting the value of <code>@posts</code> in <code>before_mount</code> means you do not have to worry about nil values while prerendering. The actual query to the server is not initiated at this stage, but when the component is rendering.</p>

<h2 id="live-updates-via-synchromesh">Live updates via Synchromesh</h2>

<p><a href="https://github.com/reactrb/synchromesh">Synchromesh</a> if fully integrated with Reactive Record. Changes in records are broadcast (after filtering for security) to the clients and Reactrb updates the page if and only if the user is viewing a component containing data that has changed.</p>

<p>To have the component we have written above remain fully in synch with the database and automatically update if any new posts or comments are added to the database, all we need to do is use Reactrb state:
&ldquo;`ruby</p>

<h1 id="views-components-postwithcomments_list-rb">views/components/post<em>with</em>comments_list.rb</h1>

<p>class PostsWithCommentsList &lt; React::Component::Base</p>

<p>before_mount do
    # define the Post collection as state
    state.posts! Post.all
  end</p>

<p>def render
    ul do
      # and remember to use state here
      state.posts.each do |post|
        li { post.title }
        ul do
          post.comments.each do |comment|
            li { comment.body }
          end
        end
      end
    end
  end
end
&rdquo;`
That&rsquo;s it! You need no additional code to ensure your data remains updated between all authrozed clients displaying that data.</p>

<p>See <a href="https://github.com/reactrb/synchromesh">Synchromesh</a> for how scopes are used to affect the current rendered output from models which are joined to the model being rendered.</p>

<h2 id="how-it-works">How it works</h2>

<p>Reactive Record uses your existing Active Record models (or a copy thereof) which are compiled to JavaScript and made available on the client. You can consider these to be a public version (or API) of your models.</p>

<p>Its all about lazy loading. Reactive Record lazy loads data from the server as and when it is required on the client. This prevents us from grabbing enormous association collections, or large attributes unless they are explicitly requested.</p>

<p>During prerendering we get each attribute as its requested and fill it in both on the javascript side, as well as remember that the attribute needs to be part of the download to client.</p>

<p>On the client we fill in the record data with empty values (nil, or one element collections) but only as the attribute is requested.  Each request queues up a request to get the real data from the server.</p>

<p>The ReactiveRecord class serves two purposes.  First it is the unique data corresponding to the last known state of a database record.  This means All records matching a specific database record are unique.  This is unlike AR but is important both for the lazy loading and also so that when values change react can be informed of the change.</p>

<p>Secondly it serves as name space for all the ReactiveRecord specific methods, so every AR Instance has a ReactiveRecord</p>

<p>Because there is no point in generating a new ar<em>instance everytime a search is made we cache the first ar</em>instance created. Its possible however during loading to create a new ar_instances that will in the end point to the same record.</p>

<p>Vectors are an important concept.  They are the substitute for a primary key before a record is loaded. Vectors have the form [ModelClass, method<em>call, method</em>call, method_call&hellip;]</p>

<p>Each method call is either a simple method name or an array in the form [method_name, param, param &hellip;]</p>

<p>Example <code>[User, [find, 123], todos, active, [due, &quot;1/1/2016&quot;], title]</code></p>

<p>Roughly corresponds to this query:</p>

<p><code>User.find(123).todos.active.due(&quot;1/1/2016&quot;).select(:title)</code></p>

<h2 id="help-and-support">Help and support</h2>

<p>Head on over to <a href="https://gitter.im/reactrb/chat">gitter.im</a> to ask any questions you might have!</p>

<p><a href="https://gitter.im/reactrb/chat?utm_source=badge&amp;utm_medium=badge&amp;utm_campaign=pr-badge&amp;utm_content=badge"><img src="https://badges.gitter.im/Join%20Chat.svg" alt="Join the chat at https://gitter.im/catprintlabs/reactive-record" /></a>
<a href="https://codeclimate.com/github/reactrb/reactive-record"><img src="https://codeclimate.com/github/reactrb/reactive-record/badges/gpa.svg" alt="Code Climate" /></a>
<a href="https://badge.fury.io/rb/reactive-record"><img src="https://badge.fury.io/rb/reactive-record.svg" alt="Gem Version" /></a></p>

<p>For an example applcation see <a href="https://reactiverb-todo.herokuapp.com/">reactrb todo</a> (live demo <a href="https://reactiverb-todo.herokuapp.com/">here.</a>)</p>

<h2 id="notes">Notes</h2>

<ul>
<li><p>Reactive Record &gt;= 0.8.x depends on the reactrb gem.  You must <a href="https://github.com/reactrb/reactrb#upgrading-to-reactrb">upgrade to reactrb</a></p></li>
<li><p>Therubyracer has been removed as a dependency to allow the possibility of using other JS runtimes. Please make sure if you&rsquo;re upgrading that you have it (or another runtime) required in your gemfile.</p></li>
<li><p>We have dropped suppport for the ability to have rails load the same Class <em>automatically</em> from two different files, one with server side code, and one with client side code. If you need this functionality load the following code to your config/application.rb file.  However we found from experience that this was very confusing, and you are better off to explicitly include modules as needed.</p></li>
</ul>
<pre class="highlight ruby"><code><span class="n">module</span> <span class="o">::</span><span class="no">ActiveRecord</span>
  <span class="k">module</span> <span class="nn">Core</span>
    <span class="k">module</span> <span class="nn">ClassMethods</span>
      <span class="k">def</span> <span class="nf">inherited</span><span class="p">(</span><span class="n">child_class</span><span class="p">)</span>
        <span class="k">begin</span>
          <span class="n">file</span> <span class="o">=</span> <span class="no">Rails</span><span class="p">.</span><span class="nf">root</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="s1">'app'</span><span class="p">,</span><span class="s1">'models'</span><span class="p">,</span>
            <span class="s2">"</span><span class="si">#{</span><span class="n">child_class</span><span class="p">.</span><span class="nf">name</span><span class="p">.</span><span class="nf">underscore</span><span class="si">}</span><span class="s2">.rb"</span><span class="p">).</span><span class="nf">to_s</span> <span class="k">rescue</span> <span class="kp">nil</span>
          <span class="k">begin</span>
            <span class="nb">require</span> <span class="n">file</span>
          <span class="k">rescue</span> <span class="no">LoadError</span>
          <span class="k">end</span>
          <span class="c1"># from active record:</span>
          <span class="n">child_class</span><span class="p">.</span><span class="nf">initialize_find_by_cache</span>
        <span class="k">rescue</span>
        <span class="k">end</span> <span class="c1"># if File.exist?(Rails.root.join('app', 'view', 'models.rb'))</span>
        <span class="k">super</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
<h2 id="running-tests">Running tests</h2>

<p>The test suite runs in opal on a rails server, so the test database is actually the test_app&rsquo;s dev database.</p>

<ul>
<li><code>cd spec/test_app</code></li>
<li><code>rake db:reset</code> (to prepare the &ldquo;test&rdquo; database)</li>
<li><code>rails s</code></li>
<li>visit localhost:3000/spec-opal to run the suite.
Note: If any tests fail when running the entire suite, there is a good possibility that you will need to run <code>rake db:reset</code> to fix the database before running the tests again.</li>
</ul>

<h2 id="contributions">Contributions</h2>

<p>This project is still in early stage, so discussion, bug reports and PRs are really welcome ðŸ˜‰.</p>

<h2 id="license">License</h2>

<p>In short, Reactive Record is available under the MIT license. See the LICENSE file for more info.</p>

      </section>


  </body>
</html>
