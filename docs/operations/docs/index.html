<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv='X-UA-Compatible' content='IE=edge;chrome=1' />
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

    <meta name="google-site-verification" content="qjqVOvRhHfsuDbLOvaAnj2mkUZJ9Xwzg84TMVXduvUc" />

    <meta charset="UTF-8">
    <title>Hyperloop</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <script src="https://unpkg.com/react@15/dist/react.min.js"></script>
    <script src="https://unpkg.com/react-dom@15/dist/react-dom.min.js"></script>

    <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/marked/0.3.5/marked.min.js"></script>


    <!-- Opal and Hyperloop -->
    <script src="https://rawgit.com/ruby-hyperloop/hyperloop-js/master/opal-compiler.min.js"></script>
    <script src="https://rawgit.com/ruby-hyperloop/hyperloop-js/master/hyperloop.min.js"></script>

    <!-- If you want local copies... -->
    <!-- <script src="../../../javascripts/opal-compiler.js"></script> -->
    <!-- <script src="../../../javascripts/hyperloop.js"></script> -->

    <script src="https://npmcdn.com/tether@1.2.4/dist/js/tether.min.js"></script>

    <script src="../../../javascripts/bootstrap.min.js"></script>
    <script src="../../../javascripts/codemirror.js"></script>
    <script src="../../../javascripts/ruby.js"></script>
    <script src="../../../javascripts/matchbrackets.js"></script>
    <script src="../../../javascripts/react_player.js"></script>
    <script src="../../../javascripts/highlight.pack.js"></script>


    <!-- Components are compiled by Hyperloop Express -->
    <script type="text/ruby">

class CodeMirror < Hyperloop::Component
  param :code, type: String
  param :heading, default: "Code"
  param :rows, type: Integer, default: 0
  param :top_level_component, type: String

  before_mount do
    r=rand(2**256).to_s(36)[0..7]
    @div_code = "code_#{r}"
    @div_result = "result_#{r}"
  end

  after_mount do
  # puts params.code
    @editor = `CodeMirror(document.getElementById(#{@div_code}), {
      value: #{params.code.to_s},
      mode: 'text/x-ruby',
      matchBrackets: true,
      lineNumbers: false,
      indentUnit: 2,
      theme: 'github'
    });`

    `#{@editor}.on('change', #{lambda {on_change} })`
    `#{@editor}.setSize(null, #{@editor}.defaultTextHeight()*#{params.rows})` unless params.rows == 0
    execute_code
  end

  render(DIV) do
    div.card {
      div.card_header { params.heading }
      div(id: @div_code)
      div.card_header do
        img(src: '../../../images/hyperloop-logo-small-white.png' , width:'25')
        span { ' ' }
        'Live editor results'
      end
      div.card_block(id: @div_result)
    }
  end

  def on_change
    execute_code
  end

  def execute_code
    begin
      code = `#{@editor}.getValue()`
      # puts code
      code += "\nElement['##{@div_result}'].render(#{params.top_level_component})"
      compiled_code = Opal::Compiler.new(code).compile

      `ReactDOM.unmountComponentAtNode(document.getElementById(#{@div_result}));`

      # Dispatchers and Receivers example works but Steps example breaks
      # Hyperloop::Context.reset!
      # `eval(#{compiled_code})`
      # Hyperloop::Application::Boot.run()

      # Steps example works but Dispatchers and Receivers example breaks
      `eval(#{compiled_code})`
      Hyperloop::Context.reset!
      Hyperloop::Application::Boot.run()

      component = Module.const_get params.top_level_component
      # we need to see if the component is valid - try checking if it can render static markup
      # the following line generates: `undefined method to_n for SimpleComponent`
      # if React.render_to_static_markup( component ).empty?
      #   invalid_component_message
      # end
    rescue Exception => e
      @time_out = after(0.1) do
        unable_to_compile_message e.message
      end
    end
  end

  def invalid_component_message
    message = div.text_danger do
      h3.text_danger {"Oops, invalid Component..."}
      p { "Your Component has been rejected by React. A valid Component must have a render macro and return just one HTML element." }
    end
    Element["##{@div_result}"].render{ message }
  end

  def unable_to_compile_message reason
    message = div.text_danger do
      h3.text_danger {"Can't compile..."}
      p { reason }
    end
    Element["##{@div_result}"].render{ message }
  end

end

</script>

    <script type="text/ruby">

Document.ready? do
   Element.find('div.codemirror-live-edit').each do |mount_point|
     heading = mount_point.attr('data-heading')
     rows = mount_point.attr('data-rows')
     top_level_component = mount_point.attr('data-top-level-component')
     code = Element[mount_point].find('pre').text.strip
     params = {code: code, top_level_component: top_level_component}
     params = params.merge({heading: heading}) if heading
     params = params.merge({rows: rows.to_i}) if rows
     codemirror_component = Object.const_get('CodeMirror')
     React.render(React.create_element(codemirror_component, params ), mount_point)
   end
end

</script>

    
    <script type="text/ruby">

class ToggleCodemirror < Hyperloop::Component
  param :code, type: String
  param :heading, default: "Code"
  param :rows, type: Integer, default: 0
  param :top_level_component, type: String
  param :show_code

  before_mount do
    r=rand(2**256).to_s(36)[0..7]
    @div_code = "code_#{r}"
    @div_result = "result_#{r}"
  end

  after_mount do
  # puts params.code
    @editor = `CodeMirror(document.getElementById(#{@div_code}), {
      value: #{params.code.to_s},
      mode: 'text/x-ruby',
      matchBrackets: true,
      lineNumbers: false,
      indentUnit: 2,
      readOnly: true,
      theme: 'github'
    });`

    `#{@editor}.setSize(null, #{@editor}.defaultTextHeight()*#{params.rows})` unless params.rows == 0

    Element['.codediv'].hide('')
    mutate.show_code false
    
  end

  render(DIV) do
    div.card {
      div.card_header do
        div(class: 'row') do
          div(class: 'col-md-6') do
            img(src: '../../../images/hyperloop-logo-small-white.png' , width:'25') 
            span { ' ' }
            span { params.heading }
          end
          div(class: 'col-md-6 align-right') do

            toggle_link
          end
        end
      end

      div(id: @div_code, class: 'codediv') 
    }
  end

  def toggle_link
    
      BUTTON(class: 'btn btn-info btn-sm') do
        state.show_code ? "Click to hide code" : "Click to show code"
      end.on(:click) do |ev|
        mutate.show_code !state.show_code 
        state.show_code ? Element["##{@div_code}"].show('') : Element["##{@div_code}"].hide('')
      end
    
  end

 
end

</script>

    <script type="text/ruby">

Document.ready? do
    Element.find('div.togglecode').each do |mount_point|
        heading = mount_point.attr('data-heading')
        rows = mount_point.attr('data-rows')
        top_level_component = mount_point.attr('data-top-level-component')
        code = Element[mount_point].find('pre').text.strip
        params = {code: code, top_level_component: top_level_component}
        params = params.merge({heading: heading}) if heading
        params = params.merge({rows: rows.to_i}) if rows
        codemirror_component = Object.const_get('ToggleCodemirror')
        React.render(React.create_element(codemirror_component, params ), mount_point)
    end
end

</script>

    <link href="../../../stylesheets/bootstrap.min.css" rel="stylesheet" />
    <link href="../../../stylesheets/typography.css" rel="stylesheet" />
    <link href="../../../stylesheets/override.css" rel="stylesheet" />
    <link href="../../../stylesheets/divtable.css" rel="stylesheet" />
    <!-- <link href="../../../stylesheets/code.css" rel="stylesheet" /> -->
    <link href="../../../stylesheets/github.css" rel="stylesheet" />
    <link href="../../../stylesheets/highlighting.css" rel="stylesheet" />
    <link href="../../../stylesheets/codemirror.css" rel="stylesheet" />
    <link href="../../../stylesheets/monokai-sublime.css" rel="stylesheet" />

    <link rel="alternate" type="application/atom+xml" title="Atom Feed" href="/feed.xml" />

    <!-- Favicons -->

    <link rel="apple-touch-icon" sizes="180x180" href="../../../images/apple-touch-icon.png">
    <link rel="icon" type="image/png" href="../../../images/favicon-32x32.png" sizes="32x32">
    <link rel="icon" type="image/png" href="../../../images/favicon-16x16.png" sizes="16x16">
    <link rel="manifest" href="/images/manifest.json">
    <link rel="mask-icon" href="../../../images/safari-pinned-tab.svg" color="#e81176">
    <meta name="theme-color" content="#ffffff">

  </head>

  <body>
    <div class="navbarbackgroundcolor">
      <div class="container">
        <nav class="navbar navbar-ligh">
  <button class="navbar-toggler hidden-sm-up" type="button" data-toggle="collapse" data-target="#exCollapsingNavbar2" aria-controls="exCollapsingNavbar2" aria-expanded="false" aria-label="Toggle navigation">
    &#9776;
  </button>
  <div class="collapse navbar-toggleable-xs" id="exCollapsingNavbar2">
    <ul class="nav navbar-nav">
      <li class="nav-item">
        <a href="/" class="nav-link"><span class='navfirstletter'>H</span>yperloop</a>
      </li>
      <li class="nav-item">
        <a href="/start/components" class="nav-link active"><span class='navfirstletter'>S</span>tart</a>
      </li>
      <li class="nav-item">
        <a href="/installation" class="nav-link"><span class='navfirstletter'>I</span>nstallation</a>
      </li>
      <li class="nav-item">
        <a href="/tutorials" class="nav-link"><span class='navfirstletter'>T</span>utorials</a>
      </li>
      <li class="nav-item">
        <a href="/gems" class="nav-link"><span class='navfirstletter'>G</span>ems</a>
      </li>
      <li class="nav-item">
        <a href="https://github.com/ruby-hyperloop" class="nav-link"><span class='navfirstletter'>G</span>ithub</a>
      </li>
      <li class="nav-item">
        <a href="/tools" class="nav-link"><span class='navfirstletter'>T</span>ools</a>
      </li>
      <li class="nav-item">
        <a href="/docs/architecture" class="nav-link"><span class='navfirstletter'>D</span>ocs</a>
      </li>
      <li class="nav-item">
        <a href="/help" class="nav-link"><span class='navfirstletter'>H</span>elp</a>
      </li>
      <li class="nav-item">
        <a href="/blog" class="nav-link"><span class='navfirstletter'>B</span>log</a>
      </li>
      <li class="nav-item">
        <a href="/showcase" class="nav-link"><span class='navfirstletter'>S</span>howcase</a>
      </li>
      <!-- <li class="nav-item">
        <input type="text" name="search" />
      </li> -->
    </ul>
  </div>
</nav>

      </div>
    </div>



    <div class="jumbotron page-header">
      <div class="container">

        <div class="row hidden-sm-down">
          <div class="col-md-2">
            <div class="hyperlooplogo">
            </div>
          </div>
          <div class="col-md-8">

            <h1 class="display-4 project-name">Hyperloop</h1>

            <h4 class="display-7 project-tagline">
              
              Operations
            </h4>
          </div>
          
        </div>

        <div class="row hidden-md-up">
          <div class="col-md-3">
            <div class="hyperlooplogo">
            </div>
          </div>
          <div class="col-md-9">
            <h1 class="h1 project-name center-text">Hyperloop</h1>
            </br>
            <h2 class="h5 project-tagline center-text">
              Operations
            </h2>
          </div>
          
        </div>


      </div>
    </div>

    <div class="page-header-underline">
      <div class="container">

      </div>
    </div>

    <div class="container">
      <div class="row">
        <div class="col-md-3 sidenavcol">
            <ul class="nav">
    <li class="nav-item"><a href="/docs/architecture">Hyperloop Architecture</a></li>
    <ul class="nav">
      <li class="nav-item"><a href="/docs/architecture#comps-overview">COMPS Overview</a></li>
      <li class="nav-item"><a href="/docs/architecture#pragmatic-thinking">Pragmatic Thinking</a></li>
      <li class="nav-item"><a href="/docs/advancedconfiguration">Advanced configuration</a></li>
    </ul>
  </ul>

  <br>


    <ul class="nav">
      <li class="nav-item"><a href="/docs/components/dsl-overview">Hyperloop Components</a></li>
    </ul>    


  <br>


    <ul class="nav">
      <li class="nav-item"><a href="/docs/stores/overview">Hyperloop Stores</a></li>
    </ul>


  <br>


    <ul class="nav">
      <li class="nav-item"><a href="/docs/models/overview">Hyperloop Models</a></li>
    </ul>



  <br>
  
    <ul class="navtoc">
<li class="navtoc-item">
<a href="#hyperloop-operations"><span class="bigfirstletter">H</span>yperloop Operations</a>
<ul class="navtoc">
<li class="navtoc-item">
<ul class="navtoc">
<li class="navtoc-item">
<a href="#operations-have-three-core-functions">Operations have three core functions</a>
</li>
</ul>
</li>
<li class="navtoc-item">
<a href="#operations-encapsulate-business-logic">Operations encapsulate business logic</a>
<ul class="navtoc">
<li class="navtoc-item">
<a href="#operation-structure">Operation Structure</a>
</li>
<li class="navtoc-item">
<a href="#running-operations">Running Operations</a>
</li>
<li class="navtoc-item">
<a href="#parameters">Parameters</a>
</li>
<li class="navtoc-item">
<a href="#defining-execution-steps">Defining Execution Steps</a>
</li>
<li class="navtoc-item">
<a href="#promises-and-operations">Promises and Operations</a>
</li>
<li class="navtoc-item">
<a href="#early-exits">Early Exits</a>
</li>
<li class="navtoc-item">
<a href="#validation">Validation</a>
</li>
<li class="navtoc-item">
<a href="#handling-failed-operations">Handling Failed Operations</a>
</li>
<li class="navtoc-item">
<a href="#instance-versus-class-execution-context">Instance Versus Class Execution Context</a>
</li>
<li class="navtoc-item">
<a href="#the-boot-operation">The Boot Operation</a>
</li>
</ul>
</li>
<li class="navtoc-item">
<a href="#operations-can-dispatch-messages">Operations can dispatch messages</a>
<ul class="navtoc">
<li class="navtoc-item">
<a href="#dispatching-with-new-parameters">Dispatching With New Parameters</a>
</li>
<li class="navtoc-item">
<a href="#dispatching-messages-or-invoking-steps-or-both">Dispatching messages or invoking steps (or both)?</a>
</li>
</ul>
</li>
<li class="navtoc-item">
<a href="#serverops-can-be-used-to-replace-boiler-plate-apis">ServerOps can be used to replace boiler-plate APIs</a>
<ul class="navtoc">
<li class="navtoc-item">
<a href="#server-operations">Server Operations</a>
</li>
<li class="navtoc-item">
<a href="#isomorphic-operations">Isomorphic Operations</a>
</li>
<li class="navtoc-item">
<a href="#parameters-and-serverops">Parameters and ServerOps</a>
</li>
<li class="navtoc-item">
<a href="#restricting-server-code-to-the-server">Restricting server code to the server</a>
</li>
<li class="navtoc-item">
<a href="#dispatching-from-server-operations">Dispatching From Server Operations</a>
<ul class="navtoc">
<li class="navtoc-item">
<a href="#channels">Channels</a>
</li>
</ul>
</li>
<li class="navtoc-item">
<a href="#defining-connections-in-serverops">Defining Connections in ServerOps</a>
</li>
<li class="navtoc-item">
<a href="#regulating-dispatches-in-policy-classes">Regulating Dispatches in Policy Classes</a>
</li>
<li class="navtoc-item">
<a href="#serialization">Serialization</a>
</li>
<li class="navtoc-item">
<a href="#accessing-the-controller">Accessing the Controller</a>
</li>
<li class="navtoc-item">
<a href="#broadcasting-to-the-current_session">Broadcasting to the current_session</a>
</li>
</ul>
</li>
<li class="navtoc-item">
<a href="#additional-information">Additional information</a>
<ul class="navtoc">
<li class="navtoc-item">
<a href="#operation-capabilities">Operation Capabilities</a>
</li>
<li class="navtoc-item">
<a href="#background">Background</a>
</li>
<li class="navtoc-item">
<a href="#hyperloop-operations-compared-to-flux">Hyperloop Operations compared to Flux</a>
</li>
</ul>
</li>
</ul>
</li>
</ul>

  
  <br>


    <ul class="nav">
      <li class="nav-item"><strong><a href="/docs/policies/authorization">Hyperloop Policies</a></strong></li>
    </ul>



          <br>
        </div>
        <div class="col-md-9 main-content">
          <h1 id="hyperloop-operations"><span class="bigfirstletter">H</span>yperloop Operations</h1>

<p>Operations are the engine rooms of Hyperloop; they orchestrate the interactions between Components, external services, Models, and Stores. Operations provide a tidy place to keep your business logic.</p>

<p>Operations receive parameters and execute a series of steps. They have a simple structure which is not dissimilar to a Component:</p>
<pre class="highlight ruby"><code><span class="k">class</span> <span class="nc">SimpleOperation</span> <span class="o">&lt;</span> <span class="no">Hyperloop</span><span class="o">::</span><span class="no">Operation</span>
  <span class="n">param</span> <span class="ss">:anything</span>
  <span class="n">step</span> <span class="p">{</span> <span class="n">do_something</span> <span class="p">}</span>
<span class="k">end</span>

<span class="c1">#to invoke from anywhere</span>
<span class="no">SimpleOperation</span><span class="p">.</span><span class="nf">run</span><span class="p">(</span><span class="ss">anything: :something</span><span class="p">)</span>
<span class="p">.</span><span class="nf">then</span> <span class="p">{</span> <span class="n">success</span> <span class="p">}</span>
<span class="p">.</span><span class="nf">fail</span> <span class="p">{</span> <span class="nb">fail</span> <span class="p">}</span>
</code></pre>
<p>Hyperloop&#39;s Isomorphic Operations span the client and server divide automagically. Operations can run on the client, the server, and traverse between the two.</p>

<p>This goal of this documentation is to outline Operations classes and provides enough information and examples to show how to implement Operations in an application.</p>

<h3 id="operations-have-three-core-functions">Operations have three core functions</h3>

<p>Operations are packaged as one neat package but perform three different functions:</p>

<ol>
<li>Operations encapsulate business logic into a series of steps</li>
<li>Operations can dispatch messages (either on the client or between the client and server)</li>
<li>ServerOps can be used to replace boiler-plate APIs through a bi-directional RPC mechanism</li>
</ol>

<p><strong>Important to understand:</strong> There is no requirement to use all three functions. Use only the functionality your application requires.</p>

<h2 id="operations-encapsulate-business-logic">Operations encapsulate business logic</h2>

<p>In a traditional MVC architecture, the business logic ends up either in Controllers, Models, Views or some other secondary construct such as service objects, helpers, or concerns. In Hyperloop,  Operations are first class objects who&#39;s job is to mutate state in the Stores, Models, and Components. Operations are discreet logic, which is of course, testable and maintainable.</p>

<p>An Operation does the following things:</p>

<ol>
<li>receives incoming parameters, and does basic validations<br></li>
<li>performs any further validations<br></li>
<li>executes the operation<br></li>
<li>dispatches to any listeners<br></li>
<li>returns the value of the execution (step 3)</li>
</ol>

<p>These are defined by series of class methods described below.</p>

<h3 id="operation-structure">Operation Structure</h3>

<p><code>Hyperloop::Operation</code> is the base class for an <em>Operation</em></p>

<p>As an example, here is an Operation which ensures that the Model being saved always has the current <code>created_by</code> and <code>updated_by</code> <code>Member</code>.</p>
<pre class="highlight ruby"><code><span class="k">class</span> <span class="nc">SaveWithUpdatingMemberOp</span> <span class="o">&lt;</span> <span class="no">Hyperloop</span><span class="o">::</span><span class="no">Operation</span>
  <span class="n">param</span> <span class="ss">:model</span>
  <span class="n">step</span> <span class="p">{</span> <span class="n">params</span><span class="p">.</span><span class="nf">model</span><span class="p">.</span><span class="nf">created_by</span> <span class="o">=</span> <span class="no">Member</span><span class="p">.</span><span class="nf">current</span> <span class="k">if</span> <span class="n">params</span><span class="p">.</span><span class="nf">model</span><span class="p">.</span><span class="nf">new?</span> <span class="p">}</span>
  <span class="n">step</span> <span class="p">{</span> <span class="n">params</span><span class="p">.</span><span class="nf">model</span><span class="p">.</span><span class="nf">updated_by</span> <span class="o">=</span> <span class="no">Member</span><span class="p">.</span><span class="nf">current</span> <span class="p">}</span>
  <span class="n">step</span> <span class="p">{</span> <span class="n">model</span><span class="p">.</span><span class="nf">save</span><span class="p">.</span><span class="nf">then</span> <span class="p">{</span> <span class="p">}</span> <span class="p">}</span>
<span class="k">end</span>
</code></pre>
<p>This Operation is run from anywhere in the client or server code:</p>
<pre class="highlight ruby"><code><span class="no">SaveWithUpdatingMemberOp</span><span class="p">.</span><span class="nf">run</span><span class="p">(</span><span class="ss">model: </span><span class="no">MyModel</span><span class="p">)</span>
</code></pre>
<p>Operations always return Promises, and those Promises can be chained together. See the section on Promises later in this documentation for details on how Promises work.</p>

<p>Operations can invoke other Operations so you can chain a sequence of <code>steps</code> and Promises which proceed unless the previous <code>step</code> fails:</p>
<pre class="highlight ruby"><code><span class="k">class</span> <span class="nc">InvoiceOpertion</span> <span class="o">&lt;</span> <span class="no">Hyperloop</span><span class="o">::</span><span class="no">Operation</span>
  <span class="n">param</span> <span class="ss">:order</span><span class="p">,</span> <span class="ss">type: </span><span class="no">Order</span>
  <span class="n">param</span> <span class="ss">:customer</span><span class="p">,</span> <span class="ss">type: </span><span class="no">Customer</span>

  <span class="n">step</span> <span class="p">{</span> <span class="no">CheckInventoryOp</span><span class="p">.</span><span class="nf">run</span><span class="p">(</span><span class="ss">order: </span><span class="n">params</span><span class="p">.</span><span class="nf">order</span><span class="p">)</span> <span class="p">}</span>
  <span class="n">step</span> <span class="p">{</span> <span class="no">BillCustomerOp</span><span class="p">.</span><span class="nf">run</span><span class="p">(</span><span class="ss">order: </span><span class="n">params</span><span class="p">.</span><span class="nf">order</span><span class="p">,</span> <span class="ss">customer: </span><span class="n">params</span><span class="p">.</span><span class="nf">customer</span><span class="p">)</span> <span class="p">}</span>
  <span class="n">step</span> <span class="p">{</span> <span class="no">DispatchOrderOp</span><span class="p">.</span><span class="nf">run</span><span class="p">(</span><span class="ss">order: </span><span class="n">params</span><span class="p">.</span><span class="nf">order</span><span class="p">,</span> <span class="ss">customer: </span><span class="n">params</span><span class="p">.</span><span class="nf">customer</span><span class="p">)</span> <span class="p">}</span>
<span class="k">end</span>
</code></pre>
<p>This approach allows you to build readable and testable workflows in your application.</p>

<h3 id="running-operations">Running Operations</h3>

<p>To run an Operation:</p>

<ul>
<li>use the <code>run</code> method:<br></li>
</ul>
<pre class="highlight ruby"><code><span class="no">MyOperation</span><span class="p">.</span><span class="nf">run</span>
</code></pre>
<ul>
<li>passing params:</li>
</ul>
<pre class="highlight ruby"><code><span class="no">MyOperation</span><span class="p">.</span><span class="nf">run</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
</code></pre>
<ul>
<li>the <code>then</code> and <code>fail</code> methods, which will dispatch the operation and attach a promise handler:<br></li>
</ul>
<pre class="highlight ruby"><code><span class="no">MyOperation</span><span class="p">.</span><span class="nf">run</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
<span class="p">.</span><span class="nf">then</span> <span class="p">{</span> <span class="n">do_the_next_thing</span> <span class="p">}</span>
<span class="p">.</span><span class="nf">fail</span> <span class="p">{</span> <span class="nb">puts</span> <span class="s1">'failed'</span> <span class="p">}</span>
</code></pre>
<h3 id="parameters">Parameters</h3>

<p>Operations can take parameters when they are run.  Parameters are described and accessed with the same syntax as Hyperloop Components.</p>

<p>The parameter filter types and options are taken from the <a href="https://github.com/cypriss/mutations">Mutations</a> gem with the following changes:</p>

<ul>
<li>In Hyperloop::Operations all params are declared with the param macro<br></li>
<li>The type <em>can</em> be specified using the <code>type:</code> option</li>
<li>Array and hash types can be shortened to <code>[]</code> and <code>{}</code></li>
<li>Optional params either have the default value associated with the param name or by having the <code>default</code> option present</li>
<li>All other <a href="https://github.com/cypriss/mutations/wiki/Filtering-Input">Mutation filter options</a> (such as <code>:min</code>) will work the same</li>
</ul>
<pre class="highlight ruby"><code>  <span class="c1"># required param (does not have a default value)</span>
  <span class="n">param</span> <span class="ss">:sku</span><span class="p">,</span> <span class="ss">type: </span><span class="no">String</span>
  <span class="c1"># equivalent Mutation syntax</span>
  <span class="c1"># required  { string :sku }</span>

  <span class="c1"># optional params (does have a default value)</span>
  <span class="n">param</span> <span class="ss">qty: </span><span class="mi">1</span><span class="p">,</span> <span class="ss">min: </span><span class="mi">1</span>
  <span class="c1"># alternative syntax</span>
  <span class="n">param</span> <span class="ss">:qty</span><span class="p">,</span> <span class="ss">default: </span><span class="mi">1</span><span class="p">,</span> <span class="ss">min: </span><span class="mi">1</span>
  <span class="c1"># equivalent Mutation syntax</span>
  <span class="c1"># optional { integer :qty, default: 1, min: 1 }</span>
</code></pre>
<p>All incoming params are validated against the param declarations, and any errors are posted to the <code>@errors</code> instance variable.  Extra params are ignored, but missing params unless they have a default value will cause a validation error.</p>

<h3 id="defining-execution-steps">Defining Execution Steps</h3>

<p>Operations may define a sequence of steps to be executed when the operation is run, using the <code>step</code>, <code>failed</code> and <code>async</code> callback macros.</p>
<pre class="highlight ruby"><code><span class="k">class</span> <span class="nc">Reset</span> <span class="o">&lt;</span> <span class="no">Hyperloop</span><span class="o">::</span><span class="no">Operation</span>
  <span class="n">step</span> <span class="p">{</span> <span class="no">HTTP</span><span class="p">.</span><span class="nf">post</span><span class="p">(</span><span class="s1">'/logout'</span><span class="p">)</span> <span class="p">}</span>
<span class="k">end</span>
</code></pre>
<ul>
<li><code>step</code>: runs a callback - each step is run in order.</li>
<li><code>failed</code>: runs a callback if a previous <code>step</code> or validation has failed.</li>
<li><code>async</code>: will be explained below.</li>
</ul>
<pre class="highlight ruby"><code>  <span class="n">step</span>    <span class="p">{</span>  <span class="p">}</span> <span class="c1"># do something</span>
  <span class="n">step</span>    <span class="p">{</span>  <span class="p">}</span> <span class="c1"># do something else once above step is done</span>
  <span class="n">failed</span>  <span class="p">{</span>  <span class="p">}</span> <span class="c1"># do this if anything above has failed</span>
  <span class="n">step</span>    <span class="p">{</span>  <span class="p">}</span> <span class="c1"># do a third thing, unless we are on the failed track</span>
  <span class="n">failed</span>  <span class="p">{</span>  <span class="p">}</span> <span class="c1"># do this if anything above has failed</span>
</code></pre>
<p>Together <code>step</code> and <code>failed</code> form two <em>railway tracks</em>.  Initially, execution proceeds down the success track until something goes wrong; then execution switches to the failure track starting at the next <code>failed</code> statement.  Once on the failed track execution continues performing each <code>failed</code> callback and skipping any <code>step</code> callbacks.</p>

<p>Failure occurs when either an exception is raised, or a Promise fails (more on this in the next section.) The Ruby <code>fail</code> keyword can be used as a simple way to switch to the failed track.</p>

<p>Both <code>step</code> and <code>failed</code> can receive any results delivered by the previous step.   If the last step raised an exception (outside a Promise), the failure track would receive the exception object.</p>

<p>The callback may be provided to <code>step</code> and <code>failed</code> either as a block, a symbol (which will name a method), a proc, a lambda, or an Operation.</p>
<pre class="highlight ruby"><code>  <span class="n">step</span> <span class="p">{</span> <span class="nb">puts</span> <span class="s1">'hello'</span> <span class="p">}</span>
  <span class="n">step</span> <span class="ss">:say_hello</span>
  <span class="n">step</span> <span class="o">-&gt;</span> <span class="p">()</span> <span class="p">{</span> <span class="nb">puts</span> <span class="s1">'hello'</span> <span class="p">}</span>
  <span class="n">step</span> <span class="no">Proc</span><span class="p">.</span><span class="nf">new</span> <span class="p">{</span> <span class="nb">puts</span> <span class="s1">'hello'</span> <span class="p">}</span>
  <span class="n">step</span> <span class="no">SayHello</span> <span class="c1"># your params will be passed along to SayHello</span>
</code></pre>
<p>FYI: You can also use the Ruby <code>next</code> keyword as expected to leave the current step and move to the next one.</p>

<h3 id="promises-and-operations">Promises and Operations</h3>

<p>Within the browser, the code does not wait for asynchronous methods (such as HTTP requests or timers) to complete.  Operations use Opal&#39;s <a href="http://opalrb.org/docs/api/v0.10.3/stdlib/Promise.html">Promise library</a> to deal with these situations cleanly.  A Promise is an object that has three states:  It is either still pending, or has been rejected (i.e. failed), or has been successfully resolved.  A Promise can have callbacks attached to either the failed or resolved state, and these callbacks will be executed once the Promise is resolved or rejected.</p>

<p>If a <code>step</code> or <code>failed</code> callback returns a pending Promise then the execution of the operation is suspended, and the Operation will return the Promise to the caller.  If there is more track ahead, then execution will resume at the next step when the Promise is resolved.  Likewise, if the pending Promise is rejected execution will resume on the next <code>failed</code> callback.  Because of the way Promises work, the operation steps will all be completed before the resolved state is passed along to the caller so that everything will execute in its original order.</p>

<p>Likewise, the Operation&#39;s dispatch occurs when the Promise resolves as well.</p>

<p>The <code>async</code> method can be used to override the waiting behavior.  If a <code>step</code> returns a Promise, and there is an <code>async</code> callback further down the track, execution will immediately pick up at the <code>async</code>.  Any steps in between will still be run when the Promise resolves, but their results will not be passed outside of the operation.</p>

<p>These features make it easy to organize, understand and compose asynchronous code:</p>
<pre class="highlight ruby"><code><span class="k">class</span> <span class="nc">AddItemToCart</span> <span class="o">&lt;</span> <span class="no">Hyperloop</span><span class="o">::</span><span class="no">Operation</span>
  <span class="n">step</span> <span class="p">{</span> <span class="no">HTTP</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="s1">'/inventory/#{params.sku}/qty'</span><span class="p">)</span> <span class="p">}</span>
  <span class="c1"># previous step returned a Promise so next step</span>
  <span class="c1"># will execute when that Promise resolves</span>
  <span class="n">step</span> <span class="p">{</span> <span class="o">|</span><span class="n">response</span><span class="o">|</span> <span class="nb">fail</span> <span class="k">if</span> <span class="n">params</span><span class="p">.</span><span class="nf">qty</span> <span class="o">&gt;</span> <span class="n">response</span><span class="p">.</span><span class="nf">to_i</span> <span class="p">}</span>
  <span class="c1"># once we are sure we have inventory we will dispatch</span>
  <span class="c1"># to any listening stores.</span>
<span class="k">end</span>
</code></pre>
<p>Operations will <em>always</em> return a <em>Promise</em>.  If an Operation has no steps that return a Promise the value of the last step will be wrapped in a resolved Promise.  Operations can be easily changed regardless of their internal implementation:</p>
<pre class="highlight ruby"><code><span class="k">class</span> <span class="nc">QuickCheckout</span> <span class="o">&lt;</span> <span class="no">Hyperloop</span><span class="o">::</span><span class="no">Operation</span>
  <span class="n">param</span> <span class="ss">:sku</span><span class="p">,</span> <span class="ss">type: </span><span class="no">String</span>
  <span class="n">param</span> <span class="ss">qty: </span><span class="mi">1</span><span class="p">,</span> <span class="ss">type: </span><span class="no">Integer</span><span class="p">,</span> <span class="ss">minimum: </span><span class="mi">1</span>

  <span class="n">step</span> <span class="p">{</span> <span class="no">AddItemToCart</span><span class="p">(</span><span class="n">params</span><span class="p">)</span> <span class="p">}</span>
  <span class="n">step</span> <span class="no">ValidateUserDefaultCC</span>
  <span class="n">step</span> <span class="no">Checkout</span>
<span class="k">end</span>
</code></pre>
<p>You can also use <code>Promise#when</code> if you don&#39;t care about the order of Operations</p>
<pre class="highlight ruby"><code><span class="k">class</span> <span class="nc">DoABunchOStuff</span> <span class="o">&lt;</span> <span class="no">Hyperloop</span><span class="o">::</span><span class="no">Operation</span>
  <span class="n">step</span> <span class="p">{</span> <span class="no">Promise</span><span class="p">.</span><span class="nf">when</span><span class="p">(</span><span class="no">SomeOperation</span><span class="p">.</span><span class="nf">run</span><span class="p">,</span> <span class="no">SomeOtherOperation</span><span class="p">.</span><span class="nf">run</span><span class="p">)</span> <span class="p">}</span>
  <span class="c1"># dispatch when both operations complete</span>
<span class="k">end</span>
</code></pre>
<h3 id="early-exits">Early Exits</h3>

<p>Any <code>step</code> or <code>failed</code> callback, can have an immediate exit from the Operation using the <code>abort!</code> and <code>succeed!</code> methods.  The <code>abort!</code> method returns a failed Promise with any supplied parameters.  The <code>succeed!</code> method does an immediate dispatch and returns a resolved Promise with any supplied parameters.  If <code>succeed!</code> is used in a <code>failed</code> callback, it will override the failed status of the Operation.  This is especially useful if you want to dispatch in spite of failures:</p>
<pre class="highlight ruby"><code><span class="k">class</span> <span class="nc">Pointless</span> <span class="o">&lt;</span> <span class="no">Hyperloop</span><span class="o">::</span><span class="no">Operation</span>
  <span class="n">step</span> <span class="p">{</span> <span class="nb">fail</span> <span class="p">}</span>       <span class="c1"># go to failure track</span>
  <span class="n">failed</span> <span class="p">{</span> <span class="n">succeed!</span> <span class="p">}</span> <span class="c1"># dispatch and exit</span>
<span class="k">end</span>
</code></pre>
<h3 id="validation">Validation</h3>

<p>An Operation can also have some <code>validate</code> callbacks which will run before the first step.  This is a handy place to put any additional validations.  In the validate method you can add validation type messages using the <code>add_error</code> method, and these will be passed along like any other param validation failures.</p>
<pre class="highlight ruby"><code><span class="k">class</span> <span class="nc">UpdateProfile</span> <span class="o">&lt;</span> <span class="no">Hyperloop</span><span class="o">::</span><span class="no">Operation</span>
  <span class="n">param</span> <span class="ss">:first_name</span><span class="p">,</span> <span class="ss">type: </span><span class="no">String</span>  
  <span class="n">param</span> <span class="ss">:last_name</span><span class="p">,</span> <span class="ss">type: </span><span class="no">String</span>
  <span class="n">param</span> <span class="ss">:password</span><span class="p">,</span> <span class="ss">type: </span><span class="no">String</span><span class="p">,</span> <span class="ss">nils: </span><span class="kp">true</span>
  <span class="n">param</span> <span class="ss">:password_confirmation</span><span class="p">,</span> <span class="ss">type: </span><span class="no">String</span><span class="p">,</span> <span class="ss">nils: </span><span class="kp">true</span>

  <span class="n">validate</span> <span class="k">do</span>
    <span class="n">add_error</span><span class="p">(</span>
      <span class="ss">:password_confirmation</span><span class="p">,</span>
      <span class="ss">:doesnt_match</span><span class="p">,</span>
      <span class="s2">"Your new password and confirmation do not match"</span>
    <span class="p">)</span> <span class="k">unless</span> <span class="n">params</span><span class="p">.</span><span class="nf">password</span> <span class="o">==</span> <span class="n">params</span><span class="p">.</span><span class="nf">confirmation</span>
  <span class="k">end</span>

  <span class="c1"># or more simply:</span>

  <span class="n">add_error</span> <span class="ss">:password_confirmation</span><span class="p">,</span> <span class="ss">:doesnt_match</span><span class="p">,</span> <span class="s2">"Your new password and confirmation do not match"</span> <span class="k">do</span>
    <span class="n">params</span><span class="p">.</span><span class="nf">password</span> <span class="o">!=</span> <span class="n">params</span><span class="p">.</span><span class="nf">confirmation</span>
  <span class="k">end</span>

  <span class="p">.</span><span class="nf">.</span><span class="p">.</span>
<span class="nf">end</span>
</code></pre>
<p>If the validate method returns a Promise, then execution will wait until the Promise resolves.  If the Promise fails, then the current validation fails.</p>

<p><code>abort!</code> can be called from within <code>validate</code> or <code>add_error</code> to exit the Operation immediately.  Otherwise, all validations will be run and collected together, and the Operation will move onto the <code>failed</code> track.  If <code>abort!</code> is called within an <code>add_error</code> callback the error will be added before aborting.</p>

<p>You can also raise an exception directly in validate if appropriate.  If a <code>Hyperloop::AccessViolation</code> exception is raised the Operation will immediately abort, otherwise just the current validation fails.</p>

<p>To avoid further validations if there are any failures in the basic parameter validations, this can be added</p>
<pre class="highlight ruby"><code>  <span class="n">validate</span> <span class="p">{</span> <span class="nb">abort</span><span class="o">!</span> <span class="k">if</span> <span class="n">has_errors?</span> <span class="p">}</span>
</code></pre>
<p>before the first <code>validate</code> or <code>add_error</code> call.  </p>

<h3 id="handling-failed-operations">Handling Failed Operations</h3>

<p>Because Operations always return a promise, the Promise&#39;s <code>fail</code> method can be used on the Operation&#39;s result to detect failures.</p>
<pre class="highlight ruby"><code><span class="no">QuickCheckout</span><span class="p">.</span><span class="nf">run</span><span class="p">(</span><span class="ss">sku: </span><span class="n">selected_item</span><span class="p">,</span> <span class="ss">qty: </span><span class="n">selected_qty</span><span class="p">)</span>
<span class="p">.</span><span class="nf">then</span> <span class="k">do</span>
  <span class="c1"># show confirmation</span>
<span class="k">end</span>
<span class="p">.</span><span class="nf">fail</span> <span class="k">do</span> <span class="o">|</span><span class="n">exception</span><span class="o">|</span>
  <span class="c1"># whatever exception was raised is passed to the fail block</span>
<span class="k">end</span>
</code></pre>
<p>Failures to validate params result in <code>Hyperloop::ValidationException</code> which contains a <a href="https://github.com/cypriss/mutations#what-about-validation-errors">Mutations error object</a>.</p>
<pre class="highlight ruby"><code><span class="no">MyOperation</span><span class="p">.</span><span class="nf">run</span><span class="p">.</span><span class="nf">fail</span> <span class="k">do</span> <span class="o">|</span><span class="n">e</span><span class="o">|</span>
  <span class="k">if</span> <span class="n">e</span><span class="p">.</span><span class="nf">is_a?</span> <span class="no">Hyperloop</span><span class="o">::</span><span class="no">ValidationException</span>
    <span class="n">e</span><span class="p">.</span><span class="nf">errors</span><span class="p">.</span><span class="nf">symbolic</span>     <span class="c1"># hash: each key is a parameter that failed validation,</span>
                          <span class="c1"># value is a symbol representing the reason</span>
    <span class="n">e</span><span class="p">.</span><span class="nf">errors</span><span class="p">.</span><span class="nf">message</span>      <span class="c1"># same as symbolic but message is in English</span>
    <span class="n">e</span><span class="p">.</span><span class="nf">errors</span><span class="p">.</span><span class="nf">message_list</span> <span class="c1"># array of messages where failed parameter is</span>
                          <span class="c1"># combined with the message</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
<h3 id="instance-versus-class-execution-context">Instance Versus Class Execution Context</h3>

<p>Typically the Operation&#39;s steps are declared and run in the context of an instance of the Operation.  An instance of the Operation is created, runs and is thrown away.  </p>

<p>Sometimes it&#39;s useful to run a step (or other macro such as <code>validate</code>) in the context of the class.  This is useful especially for caching values between calls to the Operation.  This can be done by defining the steps in the class context, or by providing the option <code>scope: :class</code> to the step.</p>

<p>Note that the primary use should be in interfacing to an outside APIs. Application state should not be hidden inside an Operation, and it should be moved to a Store.</p>
<pre class="highlight ruby"><code><span class="k">class</span> <span class="nc">GetRandomGithubUser</span> <span class="o">&lt;</span> <span class="no">Hyperloop</span><span class="o">::</span><span class="no">Operation</span>
  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">reload_users</span>
    <span class="vi">@promise</span> <span class="o">=</span> <span class="no">HTTP</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="s2">"https://api.github.com/users?since=</span><span class="si">#{</span><span class="nb">rand</span><span class="p">(</span><span class="mi">500</span><span class="p">)</span><span class="si">}</span><span class="s2">"</span><span class="p">).</span><span class="nf">then</span> <span class="k">do</span> <span class="o">|</span><span class="n">response</span><span class="o">|</span>
      <span class="vi">@users</span> <span class="o">=</span> <span class="n">response</span><span class="p">.</span><span class="nf">json</span><span class="p">.</span><span class="nf">collect</span> <span class="k">do</span> <span class="o">|</span><span class="n">user</span><span class="o">|</span>
        <span class="p">{</span> <span class="ss">name: </span><span class="n">user</span><span class="p">[</span><span class="ss">:login</span><span class="p">],</span> <span class="ss">website: </span><span class="n">user</span><span class="p">[</span><span class="ss">:html_url</span><span class="p">],</span> <span class="ss">avatar: </span><span class="n">user</span><span class="p">[</span><span class="ss">:avatar_url</span><span class="p">]</span> <span class="p">}</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>
  <span class="nb">self</span><span class="p">.</span><span class="nf">class</span><span class="p">.</span><span class="nf">step</span> <span class="k">do</span> <span class="c1"># as one big step</span>
    <span class="k">return</span> <span class="vi">@users</span><span class="p">.</span><span class="nf">delete_at</span><span class="p">(</span><span class="nb">rand</span><span class="p">(</span><span class="vi">@users</span><span class="p">.</span><span class="nf">length</span><span class="p">))</span> <span class="k">unless</span> <span class="vi">@users</span><span class="p">.</span><span class="nf">blank?</span>
    <span class="n">reload_users</span> <span class="k">unless</span> <span class="vi">@promise</span> <span class="o">&amp;&amp;</span> <span class="vi">@promise</span><span class="p">.</span><span class="nf">pending?</span>
    <span class="vi">@promise</span><span class="p">.</span><span class="nf">then</span> <span class="p">{</span> <span class="n">run</span> <span class="p">}</span>
  <span class="k">end</span>
<span class="k">end</span>
<span class="c1"># or</span>
<span class="k">class</span> <span class="nc">GetRandomGithubUser</span> <span class="o">&lt;</span> <span class="no">Hyperloop</span><span class="o">::</span><span class="no">Operation</span>
  <span class="k">class</span> <span class="o">&lt;&lt;</span> <span class="nb">self</span> <span class="c1"># as 4 steps - whatever you like</span>
    <span class="n">step</span>  <span class="p">{</span> <span class="n">succeed!</span> <span class="vi">@users</span><span class="p">.</span><span class="nf">delete_at</span><span class="p">(</span><span class="nb">rand</span><span class="p">(</span><span class="vi">@users</span><span class="p">.</span><span class="nf">length</span><span class="p">))</span> <span class="k">unless</span> <span class="vi">@users</span><span class="p">.</span><span class="nf">blank?</span> <span class="p">}</span>
    <span class="n">step</span>  <span class="p">{</span> <span class="n">succeed!</span> <span class="vi">@promise</span><span class="p">.</span><span class="nf">then</span> <span class="p">{</span> <span class="n">run</span> <span class="p">}</span> <span class="k">if</span> <span class="vi">@promise</span> <span class="o">&amp;&amp;</span> <span class="vi">@promise</span><span class="p">.</span><span class="nf">pending?</span> <span class="p">}</span>
    <span class="n">step</span>  <span class="p">{</span> <span class="nb">self</span><span class="p">.</span><span class="nf">class</span><span class="p">.</span><span class="nf">reload_users</span> <span class="p">}</span>
    <span class="n">async</span> <span class="p">{</span> <span class="vi">@promise</span><span class="p">.</span><span class="nf">then</span> <span class="p">{</span> <span class="n">run</span> <span class="p">}</span> <span class="p">}</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
<p>An instance of the operation is always created to hold the current parameter values, dispatcher, etc.  The first parameter to a class level <code>step</code> block or method (if it takes parameters) will always be the instance.</p>
<pre class="highlight ruby"><code><span class="k">class</span> <span class="nc">Interesting</span> <span class="o">&lt;</span> <span class="no">Hyperloop</span><span class="o">::</span><span class="no">Operation</span>
  <span class="n">param</span> <span class="ss">:increment</span>
  <span class="n">param</span> <span class="ss">:multiply</span>
  <span class="n">outbound</span> <span class="ss">:result</span>
  <span class="n">outbound</span> <span class="ss">:total</span>
  <span class="n">step</span> <span class="ss">scope: :class</span> <span class="p">{</span> <span class="vi">@total</span> <span class="o">||=</span> <span class="mi">0</span> <span class="p">}</span>
  <span class="n">step</span> <span class="ss">scope: :class</span> <span class="p">{</span> <span class="o">|</span><span class="n">op</span><span class="o">|</span> <span class="n">op</span><span class="p">.</span><span class="nf">params</span><span class="p">.</span><span class="nf">result</span> <span class="o">=</span> <span class="n">op</span><span class="p">.</span><span class="nf">params</span><span class="p">.</span><span class="nf">increment</span> <span class="o">*</span> <span class="n">op</span><span class="p">.</span><span class="nf">params</span><span class="p">.</span><span class="nf">multiply</span> <span class="p">}</span>
  <span class="n">step</span> <span class="ss">scope: :class</span> <span class="p">{</span> <span class="o">|</span><span class="n">op</span><span class="o">|</span> <span class="n">op</span><span class="p">.</span><span class="nf">params</span><span class="p">.</span><span class="nf">total</span> <span class="o">=</span> <span class="p">(</span><span class="vi">@total</span> <span class="o">+=</span> <span class="n">op</span><span class="p">.</span><span class="nf">params</span><span class="p">.</span><span class="nf">result</span><span class="p">)</span> <span class="p">}</span>
  <span class="n">dispatch</span>
<span class="k">end</span>
</code></pre>
<h3 id="the-boot-operation">The Boot Operation</h3>

<p>Hyperloop includes one predefined Operation, <code>Hyperloop::Application::Boot</code>, that runs at system initialization.  Stores can receive <code>Hyperloop::Application::Boot</code> to initialize their state.  To reset the state of the application, you can just execute <code>Hyperloop::Application::Boot</code></p>

<h2 id="operations-can-dispatch-messages">Operations can dispatch messages</h2>

<p>Hyperloop Operations borrow from the Flux pattern where Operations are dispatchers and Stores are receivers.  The choice to use Operations in this depends entirely on the needs and design of your application.</p>

<p>To illustrate this point, here is the simplest Operation:</p>
<pre class="highlight ruby"><code><span class="k">class</span> <span class="nc">Reset</span> <span class="o">&lt;</span> <span class="no">Hyperloop</span><span class="o">::</span><span class="no">Operation</span>
<span class="k">end</span>
</code></pre>
<p>To &#39;Reset&#39; the system you would say</p>
<pre class="highlight ruby"><code>  <span class="no">Reset</span><span class="p">.</span><span class="nf">run</span>
</code></pre>
<p>Elsewhere your HyperStores can receive the Reset <em>Dispatch</em> using the <code>receives</code> macro:</p>
<pre class="highlight ruby"><code><span class="k">class</span> <span class="nc">Cart</span> <span class="o">&lt;</span> <span class="no">Hyperloop</span><span class="o">::</span><span class="no">Store</span>
  <span class="n">receives</span> <span class="no">Reset</span> <span class="k">do</span>
    <span class="n">mutate</span><span class="p">.</span><span class="nf">items</span> <span class="no">Hash</span><span class="p">.</span><span class="nf">new</span> <span class="p">{</span> <span class="o">|</span><span class="n">h</span><span class="p">,</span> <span class="n">k</span><span class="o">|</span> <span class="n">h</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">}</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
<p>Note that multiple stores can receive the same <em>Dispatch</em>.</p>

<blockquote>
<p><strong>Note: Flux pattern vs. Hyperloop Operations</strong> Operations serve the role of both Action Creators and Dispatchers described in the Flux architecture. We chose the name <code>Operation</code> rather than <code>Action</code> or <code>Mutation</code> because we feel it best captures all the capabilities of a <code>Hyperloop::Operation</code>.  Nevertheless, Operations are fully compatible with the Flux Pattern.  </p>
</blockquote>

<h3 id="dispatching-with-new-parameters">Dispatching With New Parameters</h3>

<p>The <code>dispatch</code> method sends the <code>params</code> object on to any registered receivers.  Sometimes it&#39;s useful to add additional outbound params before dispatching.  Additional params can be declared using the <code>outbound</code> macro:</p>
<pre class="highlight ruby"><code><span class="k">class</span> <span class="nc">AddItemToCart</span> <span class="o">&lt;</span> <span class="no">Hyperloop</span><span class="o">::</span><span class="no">Operation</span>
  <span class="n">param</span> <span class="ss">:sku</span><span class="p">,</span> <span class="ss">type: </span><span class="no">String</span>
  <span class="n">param</span> <span class="ss">qty: </span><span class="mi">1</span><span class="p">,</span> <span class="ss">type: </span><span class="no">Integer</span><span class="p">,</span> <span class="ss">minimum: </span><span class="mi">1</span>
  <span class="n">outbound</span> <span class="ss">:available</span>

  <span class="n">step</span> <span class="p">{</span> <span class="no">HTTP</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="s1">'/inventory/#{params.sku}/qty'</span><span class="p">)</span> <span class="p">}</span>
  <span class="n">step</span> <span class="p">{</span> <span class="o">|</span><span class="n">response</span><span class="o">|</span> <span class="n">params</span><span class="p">.</span><span class="nf">available</span> <span class="o">=</span> <span class="n">response</span><span class="p">.</span><span class="nf">to_i</span> <span class="p">}</span>
  <span class="n">step</span> <span class="p">{</span> <span class="nb">fail</span> <span class="k">if</span> <span class="n">params</span><span class="p">.</span><span class="nf">qty</span> <span class="o">&gt;</span> <span class="n">params</span><span class="p">.</span><span class="nf">available</span> <span class="p">}</span>
  <span class="n">dispatch</span>
<span class="k">end</span>
</code></pre>
<h3 id="dispatching-messages-or-invoking-steps-or-both">Dispatching messages or invoking steps (or both)?</h3>

<p>Facebook is very keen on their Flux architecture where messages are dispatched between receivers. In an extensive and complicated front end application it is easy to see why they are drawn to this architecture as it creates an independence and isolation between Components.</p>

<p>As stated earlier in this documentation, the <code>step</code> idea came from Trailblazer, which is an alternative Rails architecture that posits that business functionality should not be kept in the Models, Controllers or Views.</p>

<p>In designing Hyperloop&#39;s Isomorphic Operations (which would run on the client and the server), we decided to borrow from the best of both architectures and let Operations work in either way.  The decision as to adopt the dispatching or stepping based model is left down to the programmer as determined by their preference or the needs of their application.</p>

<h2 id="serverops-can-be-used-to-replace-boiler-plate-apis">ServerOps can be used to replace boiler-plate APIs</h2>

<p>Some Operations simply do not make sense to run on the client as the resources they depend on may not be available on the client. For example, consider an Operation that needs to send an email - there is no mailer on the client so the Operation has to execute from the server.</p>

<p>That said, with our highest goal being developer productivity, it should be as invisible as possible to the developer where the Operation will execute. A developer writing front-end code should be able to invoke a server-side resource (like a mailer) just as easily as they might invoke a client-side resource.</p>

<p>Hyperloop <code>ServerOps</code> replace the need for a boiler-plate HTTP API. All serialization and de-serialization of params are handled by Hyperloop. Hyperloop automagically creates the API endpoint needed to invoke a function from the client which executes on the server and returns the results (via a Promise) to the calling client-side code.</p>

<h3 id="server-operations">Server Operations</h3>

<p>Operations will run on the client or the server. However, some Operations like <code>ValidateUserDefaultCC</code> probably need to check information server side and make secure API calls to our credit card processor.  Rather than build an API and controller to &quot;validate the user credentials&quot; you just specify that the operation must run on the server by using the <code>Hyperloop::ServerOp</code> class.</p>
<pre class="highlight ruby"><code><span class="k">class</span> <span class="nc">ValidateUserCredentials</span> <span class="o">&lt;</span> <span class="no">Hyperloop</span><span class="o">::</span><span class="no">ServerOp</span>
  <span class="n">param</span> <span class="ss">:acting_user</span>
  <span class="n">add_error</span> <span class="ss">:acting_user</span><span class="p">,</span> <span class="ss">:no_valid_default_cc</span><span class="p">,</span> <span class="s2">"No valid default credit card"</span> <span class="k">do</span>
    <span class="o">!</span><span class="n">params</span><span class="p">.</span><span class="nf">acting_user</span><span class="p">.</span><span class="nf">has_default_cc?</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
<p>A Server Operation will always run on the server even if invoked on the client.  When invoked from the client, the ServerOp will receive the <code>acting_user</code> param with the current value that your ApplicationController&#39;s <code>acting_user</code> method returns.   Typically the <code>acting_user</code> method will return either some User model or nil (if there is no logged in user.)  It&#39;s up to you to define how <code>acting_user</code> is computed, but this is easily done with any of the popular authentication gems.  Note that unless you explicitly add <code>nils: true</code> to the param declaration, nil will not be accepted.</p>

<blockquote>
<p><strong>Note regarding Rails Controllers:</strong> Hyperloop is quite flexible and rides along side Rails, without interfering. So you could still have your old controllers, and invoke them the &quot;non-hyperloop&quot; way by doing say an HTTP.post from the client, etc. Hyperloop adds a new mechanism for communicating between client and server called the Server Operation (which is a subclass of Operation.) A ServerOp has no implication on your existing controllers or code, and if used replaces controllers and client side API calls. HyperModel is built on top of Rails ActiveRecord models, and Server Operations, to keep models in sync across the application. ActiveRecord models that are made public (by moving them to the hyperloop/models folder) will automatically be synchronized across the clients and the server (subject to permissions given in the Policy classes.)
Like Server Operations, HyperModel completely removes the need to build controllers, and client side API code. However all of your current active record models, controllers will continue to work unaffected.</p>
</blockquote>

<p>As shown above, you can also define a validation to ensure further that the acting user (with perhaps other parameters) is allowed to perform the operation.  In the above case that is the only purpose of the Operation.   Another typical use would be to make sure the current acting user has the correct role to perform the operation:</p>
<pre class="highlight ruby"><code>  <span class="p">.</span><span class="nf">.</span><span class="p">.</span>
  <span class="nf">validate</span> <span class="p">{</span> <span class="k">raise</span> <span class="no">Hyperloop</span><span class="o">::</span><span class="no">AccessViolation</span> <span class="k">unless</span> <span class="n">params</span><span class="p">.</span><span class="nf">acting_user</span><span class="p">.</span><span class="nf">admin?</span> <span class="p">}</span>
  <span class="p">.</span><span class="nf">.</span><span class="o">.</span>
</code></pre>
<p>You can bake this kind logic into a superclass:</p>
<pre class="highlight ruby"><code><span class="k">class</span> <span class="nc">AdminOnlyOp</span> <span class="o">&lt;</span> <span class="no">Hyperloop</span><span class="o">::</span><span class="no">ServerOp</span>
  <span class="n">param</span> <span class="ss">:acting_user</span>
  <span class="n">validate</span> <span class="p">{</span> <span class="k">raise</span> <span class="no">Hyperloop</span><span class="o">::</span><span class="no">AccessViolation</span> <span class="k">unless</span> <span class="n">params</span><span class="p">.</span><span class="nf">acting_user</span><span class="p">.</span><span class="nf">admin?</span> <span class="p">}</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">DeleteUser</span> <span class="o">&lt;</span> <span class="no">AdminOnlyOp</span>
  <span class="n">param</span> <span class="ss">:user</span>
  <span class="n">add_error</span> <span class="ss">:user</span><span class="p">,</span> <span class="ss">:cant_delete_user</span><span class="p">,</span> <span class="s2">"Can't delete yourself, or the last admin user"</span> <span class="k">do</span>
    <span class="n">params</span><span class="p">.</span><span class="nf">user</span> <span class="o">==</span> <span class="n">params</span><span class="p">.</span><span class="nf">acting_user</span> <span class="o">||</span> <span class="p">(</span><span class="n">params</span><span class="p">.</span><span class="nf">user</span><span class="p">.</span><span class="nf">admin?</span> <span class="o">&amp;&amp;</span> <span class="no">AdminUsers</span><span class="p">.</span><span class="nf">count</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
<p>Because Operations always return a Promise, there is nothing to change on the client to call a Server Operation. A Server Operation will return a Promise that will be resolved (or rejected) when the Operation completes (or fails) on the server.  </p>

<h3 id="isomorphic-operations">Isomorphic Operations</h3>

<p>Unless the Operation is a Server Operation, it will run where it was invoked.   This can be handy if you have an Operation that needs to run on both the server and the client.  For example, an Operation that calculates the customers discount will want to run on the client so the user gets immediate feedback, and then will be run again on the server when the order is submitted as a double check.</p>

<h3 id="parameters-and-serverops">Parameters and ServerOps</h3>

<p>You cannot pass an object from the client to the server as a parameter as the server has no way of knowing the state of the object. Hyperloop takes a traditional implementation approach where an id (or some unique identifier) is passed as the parameter and the receiving code finds and created an instance of that object. For example:</p>
<pre class="highlight ruby"><code><span class="k">class</span> <span class="nc">IndexBookOp</span> <span class="o">&lt;</span> <span class="no">Hyperloop</span><span class="o">::</span><span class="no">ServerOp</span>
  <span class="n">param</span> <span class="ss">:book_id</span>
  <span class="n">step</span> <span class="p">{</span> <span class="n">index_book</span> <span class="no">Book</span><span class="p">.</span><span class="nf">find_by_id</span> <span class="n">params</span><span class="p">.</span><span class="nf">book_id</span> <span class="p">}</span>
<span class="k">end</span>
</code></pre>
<h3 id="restricting-server-code-to-the-server">Restricting server code to the server</h3>

<p>There are valid cases where you will not want your ServerOp&#39;s code to be on the client yet still be able to invoke a ServerOp from client or server code. Good reasons for this would include:</p>

<ul>
<li>Security concerns where you would not want some part of your code on the client</li>
<li>Size of code, where there will be unnecessary code downloaded to the client</li>
<li>Server code using backticks (`) or the %x{ ... } sequence, both of which are interpreted on the client as escape to generate JS code.</li>
</ul>

<p>To accomplish this, you wrap the server side implementation of the ServerOp in a <code>RUBY_ENGINE == &#39;opal&#39;</code> test which acts as a compiler directive so that this code is not compiled by Opal.</p>

<p>There are several strategies you can use to apply the RUBY_ENGINE == &#39;opal&#39; guard to your code.</p>
<pre class="highlight ruby"><code><span class="c1"># strategy 1:  guard blocks of code and declarations that you don't want to compile to the client</span>
<span class="k">class</span> <span class="nc">MyServerOp</span> <span class="o">&lt;</span> <span class="no">Hyperloop</span><span class="o">::</span><span class="no">ServerOp</span>
  <span class="c1"># stuff that is okay to compile on the client</span>
  <span class="c1"># ... etc</span>
  <span class="k">unless</span> <span class="no">RUBY_ENGINE</span> <span class="o">==</span> <span class="s1">'opal'</span>
     <span class="c1"># other code that should not be compiled to the client...</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre><pre class="highlight ruby"><code><span class="c1"># strategy 2:  guard individual methods</span>
<span class="k">class</span> <span class="nc">MyServerOp</span> <span class="o">&lt;</span> <span class="no">Hyperloop</span><span class="o">::</span><span class="no">ServerOp</span>
  <span class="c1"># stuff that is okay to compile on the client</span>
  <span class="c1"># ... etc</span>
  <span class="k">def</span> <span class="nf">my_secret_method</span>
     <span class="c1"># do something we don't want to be shown on the client</span>
   <span class="k">end</span> <span class="k">unless</span> <span class="no">RUBY_ENGINE</span> <span class="o">==</span> <span class="s1">'opal'</span>
<span class="k">end</span>
</code></pre><pre class="highlight ruby"><code><span class="c1"># strategy 3:  describe class in two pieces</span>
<span class="k">class</span> <span class="nc">MyServerOp</span> <span class="o">&lt;</span> <span class="no">Hyperloop</span><span class="o">::</span><span class="no">ServerOp</span><span class="p">;</span> <span class="k">end</span>  <span class="c1"># publically declare the operation</span>
<span class="c1"># provide the private implementation only on the server</span>
<span class="k">class</span> <span class="nc">MyServerOp</span> <span class="o">&lt;</span> <span class="no">Hyperloop</span><span class="o">::</span><span class="no">ServerOp</span>
  <span class="c1">#</span>
<span class="k">end</span> <span class="k">unless</span> <span class="no">RUBY_ENGINE</span> <span class="o">==</span> <span class="s1">'opal'</span>
</code></pre>
<p>Here is a fuller example:</p>
<pre class="highlight ruby"><code><span class="c1"># app/hyperloop/operations/list_files.rb</span>
<span class="k">class</span> <span class="nc">ListFiles</span> <span class="o">&lt;</span> <span class="no">Hyperloop</span><span class="o">::</span><span class="no">ServerOp</span>
  <span class="n">param</span> <span class="ss">:acting_user</span><span class="p">,</span> <span class="ss">nils: </span><span class="kp">true</span>
  <span class="n">param</span> <span class="ss">pattern: </span><span class="s1">'*'</span>
  <span class="n">step</span> <span class="p">{</span>  <span class="n">run_ls</span> <span class="p">}</span>

  <span class="c1"># because backticks are interpreted by the Opal compiler as escape to JS, we</span>
  <span class="c1"># have to make sure this does not compile on the client</span>
  <span class="k">def</span> <span class="nf">run_ls</span>
    <span class="sb">`ls -l </span><span class="si">#{</span><span class="n">params</span><span class="p">.</span><span class="nf">pattern</span><span class="si">}</span><span class="sb">`</span>
  <span class="k">end</span> <span class="k">unless</span> <span class="no">RUBY_ENGINE</span> <span class="o">==</span> <span class="s1">'opal'</span>
<span class="k">end</span>

<span class="c1"># app/hyperloop/components/app.rb</span>
<span class="k">class</span> <span class="nc">App</span> <span class="o">&lt;</span> <span class="no">Hyperloop</span><span class="o">::</span><span class="no">Component</span>
  <span class="n">state</span> <span class="ss">files: </span><span class="p">[]</span>

  <span class="n">after_mount</span> <span class="k">do</span>
    <span class="vi">@pattern</span> <span class="o">=</span> <span class="s1">''</span>
    <span class="n">every</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span> <span class="no">ListFiles</span><span class="p">.</span><span class="nf">run</span><span class="p">(</span><span class="ss">pattern: </span><span class="vi">@pattern</span><span class="p">).</span><span class="nf">then</span> <span class="p">{</span> <span class="o">|</span><span class="n">files</span><span class="o">|</span> <span class="n">mutate</span><span class="p">.</span><span class="nf">files</span> <span class="n">files</span><span class="p">.</span><span class="nf">split</span><span class="p">(</span><span class="s2">"</span><span class="se">\n</span><span class="s2">"</span><span class="p">)</span> <span class="p">}</span> <span class="p">}</span>
  <span class="k">end</span>

  <span class="n">render</span><span class="p">(</span><span class="no">DIV</span><span class="p">)</span> <span class="k">do</span>
    <span class="no">INPUT</span><span class="p">(</span><span class="ss">defaultValue: </span><span class="s1">''</span><span class="p">)</span>
    <span class="p">.</span><span class="nf">on</span><span class="p">(</span><span class="ss">:change</span><span class="p">)</span> <span class="p">{</span> <span class="o">|</span><span class="n">evt</span><span class="o">|</span> <span class="vi">@pattern</span> <span class="o">=</span> <span class="n">evt</span><span class="p">.</span><span class="nf">target</span><span class="p">.</span><span class="nf">value</span> <span class="p">}</span>
    <span class="no">DIV</span><span class="p">(</span><span class="ss">style: </span><span class="p">{</span><span class="ss">fontFamily: </span><span class="s1">'Courier'</span><span class="p">})</span> <span class="k">do</span>
      <span class="n">state</span><span class="p">.</span><span class="nf">files</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">file</span><span class="o">|</span>
        <span class="no">DIV</span> <span class="p">{</span> <span class="n">file</span> <span class="p">}</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
<h3 id="dispatching-from-server-operations">Dispatching From Server Operations</h3>

<p>You can also broadcast the dispatch from Server Operations to all authorized clients.  The <code>dispatch_to</code> will determine a list of <em>channels</em> to broadcast the dispatch to:</p>
<pre class="highlight ruby"><code><span class="k">class</span> <span class="nc">Announcement</span> <span class="o">&lt;</span> <span class="no">Hyperloop</span><span class="o">::</span><span class="no">ServerOp</span>
  <span class="c1"># no acting_user because we don't want clients to invoke the Operation</span>
  <span class="n">param</span> <span class="ss">:message</span>
  <span class="n">param</span> <span class="ss">:duration</span><span class="p">,</span> <span class="ss">type: </span><span class="no">Float</span><span class="p">,</span> <span class="ss">nils: </span><span class="kp">true</span>
  <span class="c1"># dispatch to the built-in Hyperloop::Application Channel</span>
  <span class="n">dispatch_to</span> <span class="no">Hyperloop</span><span class="o">::</span><span class="no">Application</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">CurrentAnnouncements</span> <span class="o">&lt;</span> <span class="no">Hyperloop</span><span class="o">::</span><span class="no">Store</span>
  <span class="n">state_reader</span> <span class="ss">all: </span><span class="p">[],</span> <span class="ss">scope: :class</span>
  <span class="n">receives</span> <span class="no">Announcement</span> <span class="k">do</span>
    <span class="n">mutate</span><span class="p">.</span><span class="nf">all</span> <span class="o">&lt;&lt;</span> <span class="n">params</span><span class="p">.</span><span class="nf">message</span>
    <span class="n">after</span><span class="p">(</span><span class="n">params</span><span class="p">.</span><span class="nf">duration</span><span class="p">)</span> <span class="p">{</span> <span class="n">delete</span> <span class="n">params</span><span class="p">.</span><span class="nf">message</span> <span class="p">}</span> <span class="k">if</span> <span class="n">params</span><span class="p">.</span><span class="nf">duration</span>
  <span class="k">end</span>
  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">delete</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
    <span class="n">mutate</span><span class="p">.</span><span class="nf">all</span><span class="p">.</span><span class="nf">delete</span> <span class="n">message</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
<h4 id="channels">Channels</h4>

<p>As seen above broadcasting is done over a <em>Channel</em>.  Any Ruby class (including Operations) can be used as <em>class channel</em>.  Any Ruby class that responds to the <code>id</code> method can be used as an <em>instance channel.</em>  </p>

<p>For example, the <code>User</code> active record model could be a used as a channel to broadcast to <em>all</em> users.  Each user instance could also be a separate instance channel that would be used to broadcast to a specific user.</p>

<p>The purpose of having channels is to restrict what gets broadcast to who, therefore typically channels represent <em>connections</em> to</p>

<ul>
<li>the application (represented by the <code>Hyperloop::Application</code> class)</li>
<li>or some function within the application (like an Operation)</li>
<li>or some class which is <em>authenticated</em> like a User or Administrator,</li>
<li>instances of those classes,</li>
<li>or instances of classes in some relationship - like a <code>team</code> that a <code>user</code> belongs to.</li>
</ul>

<p>A channel can be created by including the <code>Hyperloop::Policy::Mixin</code>,
which gives three class methods: <code>regulate_class_connection</code> <code>always_allow_connection</code> and <code>regulate_instance_connections</code>.  </p>

<p>For example...</p>
<pre class="highlight ruby"><code><span class="k">class</span> <span class="nc">User</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="kp">include</span> <span class="no">Hyperloop</span><span class="o">::</span><span class="no">Policy</span><span class="o">::</span><span class="no">Mixin</span>
  <span class="n">regulate_class_connection</span> <span class="p">{</span> <span class="nb">self</span> <span class="p">}</span>  
  <span class="n">regulate_instance_connection</span> <span class="p">{</span> <span class="nb">self</span> <span class="p">}</span>
<span class="k">end</span>
</code></pre>
<p>will attach the current acting user to the  <code>User</code> channel (which is shared with all users) and to that user&#39;s private channel.</p>

<p>Both blocks execute with <code>self</code> set to the current acting user, but the return value has a different meaning.  If <code>regulate_class_connection</code> returns any truthy value, then the class level connection will be made on behalf of the acting user.  On the other hand, if <code>regulate_instance_connection</code> returns an array (possibly nested) or Active Record relationship then an instance connection is made with each object in the list.  So, for example, you could add:</p>
<pre class="highlight ruby"><code><span class="k">class</span> <span class="nc">User</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">has_many</span> <span class="n">chat_rooms</span>
  <span class="n">regulate_instance_connection</span> <span class="p">{</span> <span class="n">chat_rooms</span> <span class="p">}</span>
  <span class="c1"># we will connect to all the chat room channels we are members of</span>
<span class="k">end</span>
</code></pre>
<p>To broadcast to all users, the Operation would have</p>
<pre class="highlight ruby"><code>  <span class="n">dispatch_to</span> <span class="p">{</span> <span class="no">User</span> <span class="p">}</span> <span class="c1"># dispatch to the User class channel</span>
</code></pre>
<p>or to send an announcement to a specific user</p>
<pre class="highlight ruby"><code><span class="k">class</span> <span class="nc">PrivateAnnouncement</span> <span class="o">&lt;</span> <span class="no">Hyperloop</span><span class="o">::</span><span class="no">ServerOp</span>
  <span class="n">param</span> <span class="ss">:receiver</span>
  <span class="n">param</span> <span class="ss">:message</span>
  <span class="c1"># dispatch_to can take a block if we need to</span>
  <span class="c1"># dynamically compute the channels</span>
  <span class="n">dispatch_to</span> <span class="p">{</span> <span class="n">params</span><span class="p">.</span><span class="nf">receiver</span> <span class="p">}</span>
<span class="k">end</span>
<span class="p">.</span><span class="nf">.</span><span class="o">.</span>
  <span class="c1"># somewhere else in the server</span>
  <span class="no">PrivateAnnouncement</span><span class="p">.</span><span class="nf">run</span><span class="p">(</span><span class="ss">receiver: </span><span class="no">User</span><span class="p">.</span><span class="nf">find_by_login</span><span class="p">(</span><span class="n">login</span><span class="p">),</span> <span class="ss">message: </span><span class="s1">'log off now!'</span><span class="p">)</span>
</code></pre>
<p>The above will work if <code>PrivateAnnouncement</code> is invoked from the server, but usually, some other client would be sending the message so the operation could look like this:</p>
<pre class="highlight ruby"><code><span class="k">class</span> <span class="nc">PrivateAnnouncement</span> <span class="o">&lt;</span> <span class="no">Hyperloop</span><span class="o">::</span><span class="no">ServerOp</span>
  <span class="n">param</span> <span class="ss">:acting_user</span>
  <span class="n">param</span> <span class="ss">:receiver</span>
  <span class="n">param</span> <span class="ss">:message</span>
  <span class="n">validate</span> <span class="p">{</span> <span class="k">raise</span> <span class="no">Hyperloop</span><span class="o">::</span><span class="no">AccessViolation</span> <span class="k">unless</span> <span class="n">params</span><span class="p">.</span><span class="nf">acting_user</span><span class="p">.</span><span class="nf">admin?</span> <span class="p">}</span>
  <span class="n">validate</span> <span class="p">{</span> <span class="n">params</span><span class="p">.</span><span class="nf">receiver</span> <span class="o">=</span> <span class="no">User</span><span class="p">.</span><span class="nf">find_by_login</span><span class="p">(</span><span class="n">receiver</span><span class="p">)</span> <span class="p">}</span>
  <span class="n">dispatch_to</span> <span class="p">{</span> <span class="n">params</span><span class="p">.</span><span class="nf">receiver</span> <span class="p">}</span>
<span class="k">end</span>
</code></pre>
<p>On the client::</p>
<pre class="highlight ruby"><code>  <span class="no">PrivateAnnouncement</span><span class="p">.</span><span class="nf">run</span><span class="p">(</span><span class="ss">receiver: </span><span class="n">login_name</span><span class="p">,</span> <span class="ss">message: </span><span class="s1">'log off now!'</span><span class="p">).</span><span class="nf">fail</span> <span class="k">do</span>
    <span class="n">alert</span><span class="p">(</span><span class="s1">'message could not be sent'</span><span class="p">)</span>
  <span class="k">end</span>
</code></pre>
<p>and elsewhere in the client code, there would be a component like this:</p>
<pre class="highlight ruby"><code><span class="k">class</span> <span class="nc">Alerts</span> <span class="o">&lt;</span> <span class="no">Hyperloop</span><span class="o">::</span><span class="no">Component</span>
  <span class="kp">include</span> <span class="no">Hyperloop</span><span class="o">::</span><span class="no">Store</span><span class="o">::</span><span class="no">Mixin</span>
  <span class="c1"># for simplicity we are going to merge our store with the component</span>
  <span class="n">state</span> <span class="ss">alert_messages: </span><span class="p">[]</span> <span class="ss">scope: :class</span>
  <span class="n">receives</span> <span class="no">PrivateAnnouncement</span> <span class="p">{</span> <span class="o">|</span><span class="n">params</span><span class="o">|</span> <span class="n">mutate</span><span class="p">.</span><span class="nf">alert_messages</span> <span class="o">&lt;&lt;</span> <span class="n">params</span><span class="p">.</span><span class="nf">message</span> <span class="p">}</span>
  <span class="n">render</span><span class="p">(</span><span class="no">DIV</span><span class="p">,</span> <span class="ss">class: :alerts</span><span class="p">)</span> <span class="k">do</span>
    <span class="no">UL</span> <span class="k">do</span>
      <span class="n">state</span><span class="p">.</span><span class="nf">alert_messages</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">message</span><span class="o">|</span>
        <span class="no">LI</span> <span class="k">do</span>
          <span class="no">SPAN</span> <span class="p">{</span> <span class="n">message</span> <span class="p">}</span>
          <span class="no">BUTTON</span> <span class="p">{</span> <span class="s1">'dismiss'</span> <span class="p">}.</span><span class="nf">on</span><span class="p">(</span><span class="ss">:click</span><span class="p">)</span> <span class="p">{</span> <span class="n">mutate</span><span class="p">.</span><span class="nf">alert_messages</span><span class="p">.</span><span class="nf">delete</span><span class="p">(</span><span class="n">message</span><span class="p">)</span> <span class="p">}</span>
        <span class="k">end</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
<p>This will (in only 28 lines of code)
+ associate a channel with each logged in user
+ invoke the PrivateAnnouncement Operation on the server (remotely from the client)
+ validate that there is a logged in user at that client
+ validate that we have a non-nil, non-blank receiver and message
+ validate that the acting<em>user is an admin
+ look up the receiver in the database under their login name
+ dispatch the parameters back to any clients where the receiver is logged in
+ those clients will update their alert</em>messages state and
+ display the message</p>

<p>The <code>dispatch_to</code> callback takes a list of classes, representing <em>Channels.</em>  The Operation will be dispatched to all clients connected to those Channels.   Alternatively <code>dispatch_to</code> can take a block, a symbol (indicating a method to call) or a proc.  The block, proc or method should return a single Channel, or an array of Channels, which the Operation will be dispatched to.   The dispatch_to callback has access to the params object.  For example, we can add an optional <code>to</code> param to our Operation, and use this to select which Channel we will broadcast to.</p>
<pre class="highlight ruby"><code><span class="k">class</span> <span class="nc">Announcement</span> <span class="o">&lt;</span> <span class="no">Hyperloop</span><span class="o">::</span><span class="no">Operation</span>
  <span class="n">param</span> <span class="ss">:message</span>
  <span class="n">param</span> <span class="ss">:duration</span>
  <span class="n">param</span> <span class="ss">to: </span><span class="kp">nil</span><span class="p">,</span> <span class="ss">type: </span><span class="no">User</span>
  <span class="c1"># dispatch to the Users channel only if specified otherwise announcement is application wide</span>
  <span class="n">dispatch_to</span> <span class="p">{</span> <span class="n">params</span><span class="p">.</span><span class="nf">to</span> <span class="o">||</span> <span class="no">Hyperloop</span><span class="o">::</span><span class="no">Application</span> <span class="p">}</span>
<span class="k">end</span>
</code></pre>
<h3 id="defining-connections-in-serverops">Defining Connections in ServerOps</h3>

<p>The policy methods <code>always_allow_connection</code> and <code>regulate_class_connection</code> may be used directly in a ServerOp class.  This will define a channel dedicated to that class, and will also dispatch to that channel when the Operation completes.</p>
<pre class="highlight ruby"><code><span class="k">class</span> <span class="nc">Announcement</span> <span class="o">&lt;</span> <span class="no">HyperLoop</span><span class="o">::</span><span class="no">ServerOp</span>
  <span class="c1"># all clients will have an Announcement Channel which will</span>
  <span class="c1"># receive all dispatches from the Announcement Operation</span>
  <span class="n">always_allow_connection</span>
<span class="k">end</span>
</code></pre><pre class="highlight ruby"><code><span class="k">class</span> <span class="nc">AdminOps</span> <span class="o">&lt;</span> <span class="no">HyperLoop</span><span class="o">::</span><span class="no">ServerOp</span>
  <span class="c1"># subclasses can be invoked from the client if an admin is logged in</span>
  <span class="c1"># and all other clients that have a logged in admin will receive the dispatch</span>
  <span class="n">regulate_class_connection</span> <span class="p">{</span> <span class="n">acting_user</span><span class="p">.</span><span class="nf">admin?</span> <span class="p">}</span>
  <span class="n">param</span> <span class="ss">:acting_user</span>
  <span class="n">validate</span> <span class="p">{</span> <span class="n">param</span><span class="p">.</span><span class="nf">acting_user</span><span class="p">.</span><span class="nf">admin?</span> <span class="p">}</span>
<span class="k">end</span>
</code></pre>
<h3 id="regulating-dispatches-in-policy-classes">Regulating Dispatches in Policy Classes</h3>

<p>Regulations and dispatch lists can be grouped and specified in Policy files, which are by convention kept in the Rails <code>app/policies</code> directory.</p>
<pre class="highlight ruby"><code><span class="c1"># app/policies/announcement_policy.rb</span>
<span class="k">class</span> <span class="nc">AnnouncementPolicy</span>
  <span class="n">always_allow_connection</span>
  <span class="n">dispatch_to</span> <span class="p">{</span> <span class="n">params</span><span class="p">.</span><span class="nf">acting_user</span> <span class="p">}</span>
<span class="k">end</span>

<span class="c1"># app/policies/user_policy.rb</span>
<span class="k">class</span> <span class="nc">UserPolicy</span>
  <span class="n">regulate_instance_connection</span> <span class="p">{</span> <span class="nb">self</span> <span class="p">}</span>
<span class="k">end</span>
</code></pre>
<h3 id="serialization">Serialization</h3>

<p>If you need to control serialization and deserialization across the wire you can define the following <em>class</em> methods:</p>
<pre class="highlight ruby"><code><span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">serialize_params</span><span class="p">(</span><span class="nb">hash</span><span class="p">)</span>
  <span class="c1"># receives param_name -&gt; value pairs</span>
  <span class="c1"># return an object ready for to_json</span>
  <span class="c1"># default is just return the input hash</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">deserialize_params</span><span class="p">(</span><span class="n">object</span><span class="p">)</span>
  <span class="c1"># recieves whatever was returned from serialize_to_server</span>
  <span class="c1"># (param_name =&gt; value pairs by default)</span>
  <span class="c1"># must return a hash of param_name =&gt; value pairs</span>
  <span class="c1"># by default this returns object</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">serialize_response</span><span class="p">(</span><span class="n">object</span><span class="p">)</span>
  <span class="c1"># receives the object ready for to_json</span>
  <span class="c1"># by default this returns object</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">deserialize_response</span><span class="p">(</span><span class="n">object</span><span class="p">)</span>
  <span class="c1"># receives whatever was returned from serialize_response</span>
  <span class="c1"># by default this returns object</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">serialize_dispatch</span><span class="p">(</span><span class="nb">hash</span><span class="p">)</span>
  <span class="c1"># input is always key - value pairs</span>
  <span class="c1"># return an object ready for to_json</span>
  <span class="c1"># default just returns the input hash</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">deserialize_dispatch</span><span class="p">(</span><span class="n">object</span><span class="p">)</span>
  <span class="c1"># recieves whatever was returned from serialize_to_server</span>
  <span class="c1"># (param_name =&gt; value pairs by default)</span>
  <span class="c1"># must return a hash of param_name =&gt; value pairs</span>
  <span class="c1"># by default this returns object</span>
<span class="k">end</span>
</code></pre>
<h3 id="accessing-the-controller">Accessing the Controller</h3>

<p>ServerOps have the ability to receive the &quot;controller&quot; as a param. This is handy for low-level stuff (like login) where you need access to the controller. There is a subclass of ServerOp called ControllerOp that simply declares this param and will delegate any controller methods to the controller param. So within a <code>ControllerOp</code> if you say <code>session</code> you will get the session object from the controller.</p>

<p>Here is a sample of the SignIn operation using the Devise Gem:</p>
<pre class="highlight ruby"><code><span class="k">class</span> <span class="nc">SignIn</span> <span class="o">&lt;</span> <span class="no">Hyperloop</span><span class="o">::</span><span class="no">ControllerOp</span>
  <span class="n">param</span> <span class="ss">:email</span>
  <span class="n">inbound</span> <span class="ss">:password</span>
  <span class="n">add_error</span><span class="p">(</span><span class="ss">:email</span><span class="p">,</span> <span class="ss">:does_not_exist</span><span class="p">,</span> <span class="s1">'that login does not exist'</span><span class="p">)</span> <span class="p">{</span> <span class="o">!</span><span class="p">(</span><span class="vi">@user</span> <span class="o">=</span> <span class="no">User</span><span class="p">.</span><span class="nf">find_by_email</span><span class="p">(</span><span class="n">params</span><span class="p">.</span><span class="nf">email</span><span class="p">))</span> <span class="p">}</span>
  <span class="n">add_error</span><span class="p">(</span><span class="ss">:password</span><span class="p">,</span> <span class="ss">:is_incorrect</span><span class="p">,</span> <span class="s1">'password is incorrect'</span><span class="p">)</span> <span class="p">{</span> <span class="o">!</span><span class="vi">@user</span><span class="p">.</span><span class="nf">valid_password?</span><span class="p">(</span><span class="n">params</span><span class="p">.</span><span class="nf">password</span><span class="p">)</span>  <span class="p">}</span>
 <span class="c1"># no longer have to do this step { params.password = nil }</span>
  <span class="n">step</span> <span class="p">{</span> <span class="n">sign_in</span><span class="p">(</span><span class="ss">:user</span><span class="p">,</span> <span class="vi">@user</span><span class="p">)</span>  <span class="p">}</span>
<span class="k">end</span>
</code></pre>
<p>In the code above there is another parameter type in ServerOps, called inbound, which will not get dispatched.</p>

<h3 id="broadcasting-to-the-current_session">Broadcasting to the current_session</h3>

<p>Let&#39;s say you would like to be able to broadcast to the current session. For example, after the user signs in we want to broadcast to all the browser windows the user happens to have open so that they can update.</p>

<p>For this, we have a <code>current_session</code> method in the <code>ControllerOp</code> that you can dispatch to.</p>
<pre class="highlight ruby"><code><span class="k">class</span> <span class="nc">SignIn</span> <span class="o">&lt;</span> <span class="no">Hyperloop</span><span class="o">::</span><span class="no">ControllerOp</span>
  <span class="n">param</span> <span class="ss">:email</span>
  <span class="n">inbound</span> <span class="ss">:password</span>
  <span class="n">add_error</span><span class="p">(</span><span class="ss">:email</span><span class="p">,</span> <span class="ss">:does_not_exist</span><span class="p">,</span> <span class="s1">'that login does not exist'</span><span class="p">)</span> <span class="p">{</span> <span class="o">!</span><span class="p">(</span><span class="vi">@user</span> <span class="o">=</span> <span class="no">User</span><span class="p">.</span><span class="nf">find_by_email</span><span class="p">(</span><span class="n">params</span><span class="p">.</span><span class="nf">email</span><span class="p">))</span> <span class="p">}</span>
  <span class="n">add_error</span><span class="p">(</span><span class="ss">:password</span><span class="p">,</span> <span class="ss">:is_incorrect</span><span class="p">,</span> <span class="s1">'password is incorrect'</span><span class="p">)</span> <span class="p">{</span> <span class="o">!</span><span class="vi">@user</span><span class="p">.</span><span class="nf">valid_password?</span><span class="p">(</span><span class="n">params</span><span class="p">.</span><span class="nf">password</span><span class="p">)</span>  <span class="p">}</span>
  <span class="n">step</span> <span class="p">{</span> <span class="n">sign_in</span><span class="p">(</span><span class="ss">:user</span><span class="p">,</span> <span class="vi">@user</span><span class="p">)</span>  <span class="p">}</span>
  <span class="n">dispatch_to</span> <span class="p">{</span> <span class="n">current_session</span> <span class="p">}</span>
<span class="k">end</span>
</code></pre>
<p>The Session channel is special so to attach to the application to it you would say in the top level component:</p>
<pre class="highlight ruby"><code><span class="k">class</span> <span class="nc">App</span> <span class="o">&lt;</span> <span class="no">Hyperloop</span><span class="o">::</span><span class="no">Component</span>
  <span class="n">after_mount</span> <span class="ss">:connect_session</span>
<span class="k">end</span>
</code></pre>
<h2 id="additional-information">Additional information</h2>

<h3 id="operation-capabilities">Operation Capabilities</h3>

<p>Operations have the following capabilities:</p>

<ul>
<li>Can easily be chained because they always return Promises</li>
<li>declare both their parameters and what they will dispatch</li>
<li>Parameters can be validated and type checked</li>
<li>Can run remotely on the server</li>
<li>Can be dispatched from the server to all authorized clients.</li>
<li>Can hold their own state data when appropriate</li>
<li>Operations also serves as the bridge between client and server</li>
<li>An operation can run on the client or the server and can be invoked remotely.</li>
</ul>

<p><strong>Use Operations as you choose</strong>. This architecture is descriptive but not prescriptive. Depending on the needs of your application and your overall thoughts on architecture, you may need a little or a lot of the functionality provided by Operations. If you chose, you could keep all your business logic in your Models, Stores or Components - we suggest that it is better application design not to do this, but the choice is yours.</p>

<h3 id="background">Background</h3>

<p>The design of Hyperloop&#39;s Operations have been inspired by three concepts: <a href="http://trailblazer.to/gems/operation/2.0/">Trailblazer Operations</a> (for encapsulating business logic in <code>steps</code>), the <a href="https://facebook.github.io/flux/">Flux pattern</a> (for dispatchers and receivers), and the <a href="https://github.com/cypriss/mutations">Mutation Gem</a> (for validating params).</p>

<h3 id="hyperloop-operations-compared-to-flux">Hyperloop Operations compared to Flux</h3>

<table><thead>
<tr>
<th>Flux</th>
<th>HyperLoop</th>
</tr>
</thead><tbody>
<tr>
<td>Action</td>
<td>Hyperloop::Operation subclass</td>
</tr>
<tr>
<td>ActionCreator</td>
<td><code>Hyperloop::Operation.step/failed/async</code> methods</td>
</tr>
<tr>
<td>Action Data</td>
<td>Hyperloop::Operation parameters</td>
</tr>
<tr>
<td>Dispatcher</td>
<td><code>Hyperloop::Operation#dispatch</code> method</td>
</tr>
<tr>
<td>Registering a Store</td>
<td><code>Store.receives</code></td>
</tr>
</tbody></table>

        </div>
      </div>
    </div>

    <div class="page-footer-upperline">
      <div class="container">

      </div>
    </div>

    <footer class="nav-footer">
  <section class="sitemap">

    <a href="/" class="nav-home"></a>

    <div>
      <h6><a href="/start/components" class="hyperloop-white">Start</a></h6>
      <a href="/start/components">Components</a>
      <a href="/start/stores">Stores</a>
      <a href="/start/models">Models</a>
      <a href="/start/operations">Operations</a>
      <a href="/start/policies">Policies</a>
      <a href="/start/pragmatic">Pragmatic Thinking</a>
    </div>
    <div>


      <h6><a href="/tutorials" class="hyperloop-white">Tutorials</a></h6>
      <a href="/tutorials/hyperloopcomps">Hyperloop COMPS</a>
      <a href="/tutorials/hyperloopjs">Hyperloop.js</a>
      <a href="/tutorials/hyperlooprails">Hyperloop and Rails</a>
      <a href="/tutorials/hyperloopdeploy">Hyperloop deployment</a>
      <a href="/tutorials/opal">Opal</a>
      <a href="/tutorials/videos">Videos</a>
    </div>
    <div>
      <h6><a href="/installation" class="hyperloop-white">Installation</a></h6>
      <a href="/installation#opal-playground">Hyperloop.js</a>
  	  <a href="/installation#ror">With Ruby On Rails</a>
  	  <a href="/installation#with-sinatra">With Sinatra</a>
  	  <a href="/installation#deployment">Deployment</a>
    </div>
    <div>
      <h6><a href="/gems" class="hyperloop-white">Gems</a></h6>
      <a href="https://github.com/ruby-hyperloop/hyperloop">hyperloop</a>
      <a href="https://github.com/ruby-hyperloop/hyperloop-js">hyperloop-js</a>
      <a href="https://github.com/ruby-hyperloop/hyper-react">hyper-component</a>
      <a href="https://github.com/ruby-hyperloop/hyper-store">hyper-store</a>
      <a href="https://github.com/ruby-hyperloop/hyper-mesh">hyper-model</a>
      <a href="https://github.com/ruby-hyperloop/hyper-operation">hyper-operation</a>
      <a href="https://github.com/ruby-hyperloop/reactrb-router/tree/v2-4-0">hyper-router</a>
      <a href="https://github.com/ruby-hyperloop/hyper-spec">hyper-spec</a>
      <a href="https://github.com/ruby-hyperloop/hyper-trace">hyper-trace</a>
    </div>
    <div>
      <h6><a href="/tools" class="hyperloop-white">Tools</a></h6>
      <a href="#testing">Testing</a>
    	<a href="#tools">Tools</a>
    	<a href="#debugging">Debugging</a>
    </div>
    <div>
      <h6><a href="/docs/architecture" class="hyperloop-white">Docs</a></h6>
      <a href="/docs/architecture">Architecture</a>
      <a href="/docs/components/dsl-overview">Components</a>
      <a href="/docs/stores/overview">Stores</a>
      <a href="/docs/models/overview">Models</a>
      <a href="/docs/operations/docs">Operations</a>
      <a href="/docs/policies/authorization">Policies</a>
    </div>

  </section>

  <section class="otherlinks">
    <a href="https://github.com/ruby-hyperloop" class="hyperloop-white">Github</a>
    <a href="/support" class="hyperloop-white">Help</a>
    <a href="/blog" class="hyperloop-white">Blog</a>
    <a href="/showcase" class="hyperloop-white">Showcase</a>
  </section>

  <section class="copyright">
    Copyright  2017 Hyperloop.
  </section>
</footer>


    <script>
      (function(Opal) {
        var self = Opal.top, $scope = Opal, nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice;
        Opal.add_stubs(['$puts']);
        return self.$puts("Opal ok")
      })(Opal);
    </script>

    <!-- <script   src="http://code.jquery.com/jquery-3.1.1.min.js"   integrity="sha256-hVVnYaiADRTO2PzUGmuLJr8BLUSjGIZsDYGmIJLv2b8="   crossorigin="anonymous"></script> -->


    <script type="text/ruby">puts "Hyperloop JS ok"</script>

    


  </body>
</html>
