<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv='X-UA-Compatible' content='IE=edge;chrome=1' />
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

    <meta name="google-site-verification" content="qjqVOvRhHfsuDbLOvaAnj2mkUZJ9Xwzg84TMVXduvUc" />

    <meta charset="UTF-8">
    <title>Hyperloop - Policies</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <script src="https://unpkg.com/react@15/dist/react.min.js"></script>
    <script src="https://unpkg.com/react-dom@15/dist/react-dom.min.js"></script>

    <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/marked/0.3.5/marked.min.js"></script>


    <!-- Opal and Hyperloop -->
    <script src="https://rawgit.com/ruby-hyperloop/hyperloop-js/master/opal-compiler.min.js"></script>
    <script src="https://rawgit.com/ruby-hyperloop/hyperloop-js/master/hyperloop.min.js"></script>

    <!-- If you want local copies... -->
    <!-- <script src="../../../javascripts/opal-compiler.js"></script> -->
    <!-- <script src="../../../javascripts/hyperloop.js"></script> -->

    <script src="https://npmcdn.com/tether@1.2.4/dist/js/tether.min.js"></script>

    <script src="../../../javascripts/bootstrap.min.js"></script>
    <script src="../../../javascripts/codemirror.js"></script>
    <script src="../../../javascripts/ruby.js"></script>
    <script src="../../../javascripts/matchbrackets.js"></script>
    <script src="../../../javascripts/react_player.js"></script>

    <!-- Components are compiled by Hyperloop Express -->
    <script type="text/ruby">

class CodeMirror < Hyperloop::Component
  param :code, type: String
  param :heading, default: "Code"
  param :rows, type: Integer, default: 0
  param :top_level_component, type: String

  before_mount do
    r=rand(2**256).to_s(36)[0..7]
    @div_code = "code_#{r}"
    @div_result = "result_#{r}"
  end

  after_mount do
  # puts params.code
    @editor = `CodeMirror(document.getElementById(#{@div_code}), {
      value: #{params.code.to_s},
      mode: 'text/x-ruby',
      matchBrackets: true,
      lineNumbers: false,
      indentUnit: 2,
      theme: 'github'
    });`

    `#{@editor}.on('change', #{lambda {on_change} })`
    `#{@editor}.setSize(null, #{@editor}.defaultTextHeight()*#{params.rows})` unless params.rows == 0
    execute_code
  end

  render(DIV) do
    div.card {
      div.card_header { params.heading }
      div(id: @div_code)
      div.card_header do
        img(src: '../../../images/hyperloop-logo-small-white.png' , width:'25')
        span { ' ' }
        'Live editor results'
      end
      div.card_block(id: @div_result)
    }
  end

  def on_change
    execute_code
  end

  def execute_code
    begin
      code = `#{@editor}.getValue()`
      # puts code
      code += "\nElement['##{@div_result}'].render(#{params.top_level_component})"
      compiled_code = Opal::Compiler.new(code).compile

      `ReactDOM.unmountComponentAtNode(document.getElementById(#{@div_result}));`

      # Dispatchers and Receivers example works but Steps example breaks
      # Hyperloop::Context.reset!
      # `eval(#{compiled_code})`
      # Hyperloop::Application::Boot.run()

      # Steps example works but Dispatchers and Receivers example breaks
      `eval(#{compiled_code})`
      Hyperloop::Context.reset!
      Hyperloop::Application::Boot.run()

      component = Module.const_get params.top_level_component
      # we need to see if the component is valid - try checking if it can render static markup
      # the following line generates: `undefined method to_n for SimpleComponent`
      # if React.render_to_static_markup( component ).empty?
      #   invalid_component_message
      # end
    rescue Exception => e
      @time_out = after(0.1) do
        unable_to_compile_message e.message
      end
    end
  end

  def invalid_component_message
    message = div.text_danger do
      h3.text_danger {"Oops, invalid Component..."}
      p { "Your Component has been rejected by React. A valid Component must have a render macro and return just one HTML element." }
    end
    Element["##{@div_result}"].render{ message }
  end

  def unable_to_compile_message reason
    message = div.text_danger do
      h3.text_danger {"Can't compile..."}
      p { reason }
    end
    Element["##{@div_result}"].render{ message }
  end

end

</script>

    <script type="text/ruby">

Document.ready? do
   Element.find('div.codemirror-live-edit').each do |mount_point|
     heading = mount_point.attr('data-heading')
     rows = mount_point.attr('data-rows')
     top_level_component = mount_point.attr('data-top-level-component')
     code = Element[mount_point].find('pre').text.strip
     params = {code: code, top_level_component: top_level_component}
     params = params.merge({heading: heading}) if heading
     params = params.merge({rows: rows.to_i}) if rows
     codemirror_component = Object.const_get('CodeMirror')
     React.render(React.create_element(codemirror_component, params ), mount_point)
   end
end

</script>


    <link href="../../../stylesheets/bootstrap.min.css" rel="stylesheet" />
    <link href="../../../stylesheets/typography.css" rel="stylesheet" />
    <link href="../../../stylesheets/override.css" rel="stylesheet" />
    <link href="../../../stylesheets/divtable.css" rel="stylesheet" />
    <!-- <link href="../../../stylesheets/code.css" rel="stylesheet" /> -->
    <link href="../../../stylesheets/github.css" rel="stylesheet" />
    <link href="../../../stylesheets/highlighting.css" rel="stylesheet" />
    <link href="../../../stylesheets/codemirror.css" rel="stylesheet" />

    <link rel="alternate" type="application/atom+xml" title="Atom Feed" href="/feed.xml" />

    <!-- Favicons -->

    <link rel="apple-touch-icon" sizes="180x180" href="../../../images/apple-touch-icon.png">
    <link rel="icon" type="image/png" href="../../../images/favicon-32x32.png" sizes="32x32">
    <link rel="icon" type="image/png" href="../../../images/favicon-16x16.png" sizes="16x16">
    <link rel="manifest" href="/images/manifest.json">
    <link rel="mask-icon" href="../../../images/safari-pinned-tab.svg" color="#e81176">
    <meta name="theme-color" content="#ffffff">

  </head>

  <body>
    <div class="navbarbackgroundcolor">
      <div class="container">
        <nav class="navbar navbar-ligh">
  <button class="navbar-toggler hidden-sm-up" type="button" data-toggle="collapse" data-target="#exCollapsingNavbar2" aria-controls="exCollapsingNavbar2" aria-expanded="false" aria-label="Toggle navigation">
    &#9776;
  </button>
  <div class="collapse navbar-toggleable-xs" id="exCollapsingNavbar2">
    <ul class="nav navbar-nav">
      <li class="nav-item">
        <a href="/" class="nav-link"><span class='navfirstletter'>H</span>yperloop</a>
      </li>
      <li class="nav-item">
        <a href="/start/components" class="nav-link active"><span class='navfirstletter'>S</span>tart</a>
      </li>
      <li class="nav-item">
        <a href="/installation" class="nav-link"><span class='navfirstletter'>I</span>nstallation</a>
      </li>
      <li class="nav-item">
        <a href="/tutorials" class="nav-link"><span class='navfirstletter'>T</span>utorials</a>
      </li>
      <li class="nav-item">
        <a href="/gems" class="nav-link"><span class='navfirstletter'>G</span>ems</a>
      </li>
      <li class="nav-item">
        <a href="https://github.com/ruby-hyperloop" class="nav-link"><span class='navfirstletter'>G</span>ithub</a>
      </li>
      <li class="nav-item">
        <a href="/tools" class="nav-link"><span class='navfirstletter'>T</span>ools</a>
      </li>
      <li class="nav-item">
        <a href="/docs/architecture" class="nav-link"><span class='navfirstletter'>D</span>ocs</a>
      </li>
      <li class="nav-item">
        <a href="/help" class="nav-link"><span class='navfirstletter'>H</span>elp</a>
      </li>
      <li class="nav-item">
        <a href="/blog" class="nav-link"><span class='navfirstletter'>B</span>log</a>
      </li>
      <li class="nav-item">
        <a href="/showcase" class="nav-link"><span class='navfirstletter'>S</span>howcase</a>
      </li>
    </ul>
  </div>
</nav>

      </div>
    </div>

    <div class="jumbotron page-header">
      <div class="container">

        <div class="row hidden-sm-down">
          <div class="col-md-2">
            <div class="hyperlooplogo">
            </div>
          </div>
          <div class="col-md-8">

            <h1 class="display-4 project-name">Hyperloop</h1>

            <h4 class="display-7 project-tagline">
              Policies
            </h4>
          </div>
          
        </div>

        <div class="row hidden-md-up">
          <div class="col-md-3 center-text">
            <img src="../../../images/hyperloop-logo-small-white.png" width="100" alt="Hyperloop logo small white" />
          </div>
          <div class="col-md-9">
            <h1 class="h1 project-name center-text">Hyperloop</h1>
            </br>
            <h2 class="h5 project-tagline center-text">
              Policies
            </h2>
          </div>
          
        </div>


      </div>
    </div>

    <div class="page-header-underline">
      <div class="container">

      </div>
    </div>

    <div class="container">
      <div class="row">
        <div class="col-md-3 sidenavcol">
            <ul class="nav">
    <li class="nav-item"><a href="/docs/architecture">Hyperloop Architecture</a></li>
    <ul class="nav">
      <li class="nav-item"><a href="/docs/architecture#comps-overview">COMPS Overview</a></li>
      <li class="nav-item"><a href="/docs/architecture#pragmatic-thinking">Pragmatic Thinking</a></li>
      <li class="nav-item"><a href="/docs/advancedconfiguration">Advanced configuration</a></li>
    </ul>
  </ul>

  <br>
  <ul class="nav">
    <li class="nav-item"><a href="/docs/components/dsl-overview">Components</a></li>
    <ul class="nav">
      <li class="nav-item"><a href="/docs/components/components-and-state">Components and State</a></br></li>
      <li class="nav-item"><a href="/docs/components/lifecycle-callbacks">Lifecycle Callbacks</a></br></li>
      <li class="nav-item"><a href="/docs/components/lifecycle-methods">Lifecycle Methods</a></br></li>
      <li class="nav-item"><a href="/docs/components/event-handelers">Event Handelers</a></br></li>
      <li class="nav-item"><a href="/docs/components/elements-rendering">Elements and Rendering</a></br></li>
      <li class="nav-item"><a href="/docs/components/javascript-components">Javascript Components</a></br></li>
      <li class="nav-item"><a href="/docs/components/further-reading">Further Reading</a></br></li>
    </ul>
  </ul>

  <br>
  <ul class="nav">
    <li class="nav-item"><a href="/docs/stores/overview">Stores</a></li>
    <ul class="nav">
      <li class="nav-item"><a href="/docs/stores/overview#receiving-operation-dispatches">Receiving Operation Dispatches</a></li>
      <li class="nav-item"><a href="/docs/stores/overview#reading-and-mutating-states">Reading and Mutating States</a></li>
      <li class="nav-item"><a href="/docs/stores/overview#instances-and-classes">Instances and Classes</a></li>
      <li class="nav-item"><a href="/docs/stores/overview#explicitly-declaring-states">Explicitly Declaring States</a></li>
      <li class="nav-item"><a href="/docs/stores/overview#hyperloop-store-mixin">Store Mixin</a></li>
    </ul>
  </ul>

  <br>
  <ul class="nav">
    <li class="nav-item"><a href="/docs/models/overview">Models</a></li>
    <ul class="nav">
      <li class="nav-item"><a href="/docs/models/active-record">ActiveRecord API</a></li>
      <li class="nav-item"><a href="/docs/models/scoping">Scoping</a></br></li>
      <li class="nav-item"><a href="/docs/models/configuring-transport">Configuring the Transort</a></li>
      <li class="nav-item"><a href="/docs/models/debugging">Debugging</a></li>
      <li class="nav-item"><a href="/docs/models/common-errors">Common Errors</a></li>
    </ul>
  </ul>

  <br>
  <ul class="nav">
    <li class="nav-item"><a href="/docs/operations/overview">Operations</a></li>
    <ul class="nav">
      <li class="nav-item"><a href="/docs/operations/overview#flux-and-operations">Flux and Operations</a></li>
      <li class="nav-item"><a href="/docs/operations/overview#defining-execution-steps">Defining Execution Steps</a></li>
      <li class="nav-item"><a href="/docs/operations/overview#promises-and-operations">Promises and Operations</a></li>
      <li class="nav-item"><a href="/docs/operations/overview#early-exits">Early Exits</a></li>
      <li class="nav-item"><a href="/docs/operations/overview#validation">Validation</a></li>
      <li class="nav-item"><a href="/docs/operations/overview#handling-failed-operations">Handling Failed Operations</a></li>
      <li class="nav-item"><a href="/docs/operations/overview#running-operations">Running Operations</a></li>
      <li class="nav-item"><a href="/docs/operations/overview#server-operations">Server Operations</a></li>
      <li class="nav-item"><a href="/docs/operations/overview#dispatching-from-server-operations">Dispatching From ServerOps</a></li>
      <li class="nav-item"><a href="/docs/operations/overview#channels">Channels</a></li>
      <li class="nav-item"><a href="/docs/operations/overview#defining-connections-in-serverops">Defining Connections</a></li>
      <li class="nav-item"><a href="/docs/operations/overview#regulating-dispatches-in-policy-classes">Regulating Dispatches</a></li>
      <li class="nav-item"><a href="/docs/operations/overview#serialization">Serialization</a></li>
      <li class="nav-item"><a href="/docs/operations/overview#dispatching-with-new-parameters">Dispatching New Parameters</a></li>
      <li class="nav-item"><a href="/docs/operations/overview#instance-verses-class-execution-context">Execution Context</a></li>
      <li class="nav-item"><a href="/docs/operations/overview#the-boot-operation">The Boot Operation</a></li>
    </ul>
  </ul>

  <br>
  <ul class="nav">
    <li class="nav-item"><strong><a href="/docs/policies/authorization">Policies</a></strong></li>
    <ul class="nav">
      <li class="nav-item"><a href="/docs/policies/authorization#details">Details</a></li>
      <li class="nav-item"><a href="/docs/policies/authorization#defining-policies-and-policy-classes">Policy Classes</a></li>
      <li class="nav-item"><a href="/docs/policies/authorization#channels-and-connection-policies">Channels and connection Policies</a></li>
      <li class="nav-item"><a href="/docs/policies/authorization#class-names-instances-and-ids">Class Names Instances and IDs</a></li>
      <li class="nav-item"><a href="/docs/policies/authorization#acting-user">Acting User</a></li>
      <li class="nav-item"><a href="/docs/policies/authorization#automatic-connection">Automatic Connection</a></li>
      <li class="nav-item"><a href="/docs/policies/authorization#manually-connecting-to-channels">Manually Connecting to Channels</a></li>
      <li class="nav-item"><a href="/docs/policies/authorization#connection-sequence-summary">Connection Sequence Summary</a></li>
      <li class="nav-item"><a href="/docs/policies/authorization#disconnecting">Disconnecting</a></li>
      <li class="nav-item"><a href="/docs/policies/authorization#broadcasting-and-broadcast-policies">Broadcasting and Broadcast Policies</a></li>
      <li class="nav-item"><a href="/docs/policies/authorization#browser-initiated-change-policies">Browser Initiated Change policies</a></li>
      <li class="nav-item"><a href="/docs/policies/authorization#method-summary-and-name-space-conflicts">Method Summary and Name Space Conflicts</a></li>
    </ul>
  </ul>


          <br>
        </div>
        <div class="col-md-9 main-content">
          <h2 id="authorization">Authorization</h2>

<p>Access to your Isomorphic Models is controlled by <em>Policies</em> that describe how the current <em>acting_user</em> and <em>channels</em> may access your Models.</p>

<p>Each browser session has an <em>acting_user</em> (which may be nil) and you will define <code>create</code>, <code>update</code>, and <code>destroy</code> policies giving (or denying) the <code>acting_user</code> the ability to do these operations.</p>

<p>Read and <em>broadcast</em> access is defined based on <em>channels</em> which are connected based again on the current <code>acting_user</code>.  Read access is initiated when a specific browser tries to read a record attribute, and broadcasts are initiated whenever a model changes.</p>

<p>An application can have several channels and each channel and each active record model can have different policies to determine which attributes are sent when a record changes.</p>

<p>For example a Todo application might have an <em>instance</em> of a channel for each currently logged in user; an instance of a channel for each team if that team has one or more logged in users; and a general <code>AdminUser</code> channel shared by all administrators that are logged in.</p>

<p>Lets say a specific <code>Todo</code> changes, which is part of team id 123&#39;s Todo list, and users 7 and 8 who are members of that team are currently logged in as well as two of the <code>AdminUsers</code>.  </p>

<p>When the <code>Todo</code> changes we want all the attributes of the <code>Todo</code> broadcast on team 123&#39;s channel, as well on the <code>AdminUser</code>&#39;s channel.  Now lets say User 7 sends User 8 a private message, adding a new record to the <code>Message</code> model.  This update should only be sent to user 7 and user 8&#39;s private channels, as well as to the AdminUser channel.</p>

<p>We can define all these policies by creating the following classes:</p>
<pre class="highlight ruby"><code><span class="k">class</span> <span class="nc">UserPolicy</span> <span class="c1"># defines policies for the User class</span>
  <span class="c1"># The regulate_instance_connections method enables instances of the User</span>
  <span class="c1"># class to be treated as a channel.  </span>

  <span class="c1"># The policy is defined by a block that is executed in the context of the</span>
  <span class="c1"># current acting_user.</span>

  <span class="c1"># For our User instance connection the policy is that there must be a</span>
  <span class="c1"># logged-in user, and the connection is made to that user:</span>
  <span class="n">regulate_instance_connections</span> <span class="p">{</span> <span class="nb">self</span> <span class="p">}</span>
  <span class="c1"># If there is no logged in user self will be nil, and no connection will be</span>
  <span class="c1"># made.</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">TeamPolicy</span> <span class="c1"># defines policies for the Team class  </span>
  <span class="c1"># Users can only connect to Teams that they belong to</span>
  <span class="n">regulate_instance_connections</span> <span class="p">{</span> <span class="n">teams</span> <span class="p">}</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">AdminUserPolicy</span>
  <span class="c1"># All AdminUsers share the same connection so we setup a class wide</span>
  <span class="c1"># connection available to any users who are admins.</span>
  <span class="n">regulate_class_connection</span> <span class="p">{</span> <span class="n">admin?</span> <span class="p">}</span>

  <span class="c1"># The AdminUser channel will receive all attributes</span>
  <span class="c1"># of all records, unless the attribute is named :password</span>
  <span class="n">regulate_all_broadcasts</span> <span class="k">do</span> <span class="o">|</span><span class="n">policy</span><span class="o">|</span>
    <span class="n">policy</span><span class="p">.</span><span class="nf">send_all_but</span><span class="p">(</span><span class="ss">:password</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">TodoPolicy</span>
  <span class="c1"># Policies can be established for models that are not channels as well.</span>

  <span class="c1"># The regulate_broadcast method will describe what attributes to send</span>
  <span class="c1"># when a Todo model changes.  </span>

  <span class="c1"># The blocks of broadcast policies run in the context of the changed model</span>
  <span class="c1"># so we have access to all the models methods.  In this case Todo</span>
  <span class="c1"># belongs to a Team through the 'team' relationship.</span>
  <span class="n">regulate_broadcast</span> <span class="k">do</span> <span class="o">|</span><span class="n">policy</span><span class="o">|</span>
    <span class="c1"># send all Todo attributes to the todo's team channel</span>
    <span class="n">policy</span><span class="p">.</span><span class="nf">send_all</span><span class="p">.</span><span class="nf">to</span><span class="p">(</span><span class="n">team</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">MessagePolicy</span>
  <span class="c1"># Broadcast policies can be arbitrarily complex.  In this case we</span>
  <span class="c1"># want to broadcast the entire message to the sender and the</span>
  <span class="c1"># recipient's instance channels.  </span>
  <span class="c1"># In addition if the message is not private, then we want to send to all</span>
  <span class="c1"># the team instance channels that are shared between the sender and</span>
  <span class="c1"># recipient's teams.</span>
  <span class="n">regulate_broadcast</span> <span class="k">do</span> <span class="o">|</span><span class="n">policy</span><span class="o">|</span>
    <span class="n">policy</span><span class="p">.</span><span class="nf">send_all</span><span class="p">.</span><span class="nf">to</span><span class="p">(</span><span class="n">sender</span><span class="p">,</span> <span class="n">recipient</span><span class="p">)</span>
    <span class="n">policy</span><span class="p">.</span><span class="nf">send_all</span><span class="p">.</span><span class="nf">to</span><span class="p">(</span><span class="n">sender</span><span class="p">.</span><span class="nf">teams</span><span class="p">.</span><span class="nf">merge</span><span class="p">(</span><span class="n">recipient</span><span class="p">.</span><span class="nf">teams</span><span class="p">))</span> <span class="k">unless</span> <span class="kp">private</span><span class="p">?</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
<p>Before we begin using these channels and policies we need to first define the Reactive-Record <code>acting_user</code> method in our ApplicationController:</p>
<pre class="highlight ruby"><code><span class="k">class</span> <span class="nc">ApplicationController</span> <span class="o">&lt;</span> <span class="no">ActionController</span><span class="o">::</span><span class="no">Base</span>
  <span class="k">def</span> <span class="nf">acting_user</span>
    <span class="c1"># The acting_user method should return nil, or some object that corresponds to a</span>
    <span class="c1"># logged in user.  Specifics will depend on your application and whatever other</span>
    <span class="c1"># authentication mechanisms you are using.</span>
    <span class="vi">@acting_user</span> <span class="o">||=</span> <span class="n">session</span><span class="p">[</span><span class="ss">:current_user_id</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="no">User</span><span class="p">.</span><span class="nf">find_by_id</span><span class="p">(</span><span class="n">session</span><span class="p">[</span><span class="ss">:current_user_id</span><span class="p">])</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
<p>Note that <code>acting_user</code> is also used by ReactiveRecord&#39;s permission system.</p>

<p>Our entire set of policies is defined in 29 lines of code of which 8 actually execute the policies.  Our existing classes form the foundation, and we simply add Hyperloop specific policy directives.  Pretty sweet huh?</p>

<h3 id="details">Details</h3>

<p>Hyperloop uses <em>Policies</em> to <em>regulate</em> what <em>connections</em> are opened between clients and the server and what data is distributed over those connections.</p>

<p>Connections are made on <em>channels</em> of data flowing between the server and a number of clients.  Each channel is associated with either a class or an instance of a class.  Typically the channel class represents an entity (or is associated with an entity) that can be authenticated like a <code>User</code>, an  <code>AdminUser</code>, or a <code>Team</code> of users.  A channel associated with the class itself broadcasts data that is received by any member of that class.  A channel associated with an instance is for data that is available only to that specific instance.   </p>

<p>As Models on the server change (i.e. created, updated, or destroyed) the changes are broadcast over open channels.  What specific attributes are sent (if any) is determined by broadcast policies.</p>

<p>Broadcast policies can be associated with Models.  As the Model changes the broadcast policy will regulate what attributes of the changed model will be sent over which channels.  </p>

<p>Broadcast policies can also be associated with a channel and will regulate <em>all</em> model changes over specific channels.  In other words this is just a convenient way to associate a common policy with <em>all</em> Models.</p>

<p>Note that Models that are associated with channels can also broadcast their changes on the same or different channels.</p>

<h4 id="defining-policies-and-policy-classes">Defining Policies and Policy Classes</h4>

<p>The best way to define policies is to use a <em>Policy Class</em>.  A policy class has the same class name as the class it is regulating, with <code>Policy</code> added to the end.  Policy classes are compatible with <code>Pundit</code>, and you can add regular pundit policies as well.</p>

<p>Policies are defined using four methods:
+ <code>regulate_class_connection</code> controls connections to the class channels,
+ <code>regulate_instance_connections</code> controls connections to instance channels,
+ <code>regulate_broadcast</code> controls what data will be sent when a model or object changes and,
+ <code>regulate_all_broadcasts</code> controls what data will be sent of some channels when any model changes.</p>

<p>In addition <code>always_allow_connection</code> is short hand for <code>regulate_class_connection { true }</code></p>

<p>A policy class can be defined for which there is no regulated class.  This is useful for application wide connections, which are typically open even if no one is logged in:</p>
<pre class="highlight ruby"><code><span class="c1">#app/policies/application.rb</span>
<span class="k">class</span> <span class="nc">ApplicationPolicy</span>
  <span class="n">regulate_class_connection</span> <span class="p">{</span> <span class="kp">true</span> <span class="p">}</span>
<span class="k">end</span>
</code></pre>
<p>Note that by default policy classes go in the <code>app/policies</code> directory.  Hyperloop will require all the files in this directory.</p>

<p>If you wish, you can also add policies directly in your Models by including the <code>Hyperloop::PolicyMethods</code> module in your model.  You can then use the <code>regulate_class_connection</code>, <code>regulate_instance_connections</code>, <code>regulate_all_broadcasts</code> and <code>regulate_broadcast</code> methods directly in the model.</p>
<pre class="highlight ruby"><code><span class="k">class</span> <span class="nc">User</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="kp">include</span> <span class="no">Hyperloop</span><span class="o">::</span><span class="no">PolicyMethods</span>
  <span class="n">regulate_class_connection</span> <span class="p">.</span><span class="nf">.</span><span class="p">.</span>
  <span class="nf">regulate_instance_connections</span> <span class="p">.</span><span class="nf">.</span><span class="p">.</span>
  <span class="nf">regulate_all_broadcasts</span> <span class="p">.</span><span class="nf">.</span><span class="p">.</span>  
  <span class="nf">regulate_broadcast</span> <span class="p">.</span><span class="nf">.</span><span class="p">.</span>
<span class="nf">end</span>
</code></pre>
<p>Normally the policy methods are regulating the class with the prefix as the policy, but you can override this by providing specific class names to the policy method.  This allows you to group several different class policies together, and to reuse policies:</p>
<pre class="highlight ruby"><code><span class="k">class</span> <span class="nc">ApplicationPolicy</span>
  <span class="n">regulate_connection</span> <span class="p">{</span> <span class="p">.</span><span class="nf">.</span><span class="o">.</span> <span class="p">}</span>  <span class="c1"># Application is assumed</span>
  <span class="n">regulate_class_connection</span><span class="p">(</span><span class="no">User</span><span class="p">)</span> <span class="p">{</span> <span class="p">.</span><span class="nf">.</span><span class="o">.</span> <span class="p">}</span>
  <span class="c1"># regulate_class_connection, regulate_instance_connections and</span>
  <span class="c1"># regulate_all_broadcasts can take a list of channels.</span>
  <span class="n">regulate_all_broadcasts</span><span class="p">(</span><span class="no">User</span><span class="p">,</span> <span class="no">Application</span><span class="p">)</span>
  <span class="c1"># regulate_broadcast takes a list of object classes which</span>
  <span class="c1"># may also be channels.</span>
  <span class="n">regulate_broadcast</span><span class="p">(</span><span class="no">Todo</span><span class="p">,</span> <span class="no">Message</span><span class="p">,</span> <span class="no">User</span><span class="p">)</span> <span class="p">{</span> <span class="p">.</span><span class="nf">.</span><span class="o">.</span> <span class="p">}</span>
<span class="k">end</span>
</code></pre>
<h4 id="channels-and-connection-policies">Channels and connection policies</h4>

<p>Any ruby class that has a connection policy is a Hyperloop channel. The fully scoped name of the class becomes the root of the channel name.</p>

<p>The purpose of having channels is to restrict what gets broadcast when models change, therefore typically channels represent <em>connections</em> to</p>

<ul>
<li>the application, or some function within the application</li>
<li>or some class which is <em>authenticated</em> like a User or Administrator,</li>
<li>instances of those classes,</li>
<li>or instances of related classes.</li>
</ul>

<p>So a channel that is connected to the User class would get information readable by any logged-in user, while a channel that is connected to a specific User instance would get information readable by that specific user.</p>

<p>The <code>regulate_class_connection</code> takes a block that will execute in the context of the current acting_user (which may be nil), and if the block returns any truthy value, the connection will be made.</p>

<p>The <code>regulate_instance_connections</code> likewise takes a block that is executed in the context of the current acting_user.  The block may do one of following:</p>

<ul>
<li>raise an error meaning the connection cannot be made,</li>
<li>return a falsy value also meaning the connection cannot be made,</li>
<li>return a single object meaning the connection can be made to that object,</li>
<li>return a enumerable of objects meaning the connection can made to any member of the enumerable.</li>
</ul>

<p>Note that the object (or objects) returned are expected to be of the same class as the regulated policy.  </p>
<pre class="highlight ruby"><code><span class="c1"># Create a class connection only if the acting_user is non-nil (i.e. logged in:)</span>
<span class="n">regulate_class_connection</span> <span class="p">{</span> <span class="nb">self</span> <span class="p">}</span>
<span class="c1"># Always open the connection:</span>
<span class="n">regulate_class_connection</span> <span class="p">{</span> <span class="kp">true</span> <span class="p">}</span>
<span class="c1"># Which can be shortened to:</span>
<span class="n">always_allow_connection</span>
<span class="c1"># Create a class level connection if the acting_user is an admin:</span>
<span class="n">regulate_class_connection</span> <span class="p">{</span> <span class="n">admin?</span> <span class="p">}</span>
<span class="c1"># Create an instance connection for the current user:</span>
<span class="n">regulate_instance_connections</span> <span class="p">{</span> <span class="nb">self</span> <span class="p">}</span>
<span class="c1"># Create an instance connection for the current user if the user is an admin:</span>
<span class="n">regulate_instance_connections</span> <span class="p">{</span> <span class="nb">self</span> <span class="k">if</span> <span class="n">admin?</span> <span class="p">}</span>
<span class="c1"># create an instance_connection to the users' group</span>
<span class="n">regulate_instance_connections</span> <span class="p">{</span> <span class="n">group</span> <span class="p">}</span>
<span class="c1"># create an instance connection for any team the user belongs to</span>
<span class="n">regulate_instance_connections</span> <span class="p">{</span> <span class="n">teams</span> <span class="p">}</span>
</code></pre>
<h4 id="class-names-instances-and-ids">Class Names Instances and IDs</h4>

<p>While establishing connections, classes are represented as their fully scoped name, and instances are represented as the class name plus the result of calling <code>id</code> on the instance.</p>

<p>Typically connections are made to ActiveRecord models, and if those are in the <code>app/hyperloop/models</code> folder everything will work fine.</p>

<h4 id="acting-user">Acting User</h4>

<p>Hyperloop looks for an <code>acting_user</code> method typically defined in the ApplicationController and would normally pick up the current session user, and return an appropriate object.</p>
<pre class="highlight ruby"><code><span class="k">class</span> <span class="nc">ApplicationController</span> <span class="o">&lt;</span> <span class="no">ActiveController</span><span class="o">::</span><span class="no">Base</span>
  <span class="k">def</span> <span class="nf">acting_user</span>
    <span class="vi">@acting_user</span> <span class="o">||=</span> <span class="n">session</span><span class="p">[</span><span class="ss">:current_user_id</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="no">User</span><span class="p">.</span><span class="nf">find_by_id</span><span class="p">(</span><span class="n">session</span><span class="p">[</span><span class="ss">:current_user_id</span><span class="p">])</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
<h4 id="automatic-connection">Automatic Connection</h4>

<p>Connections to channels available to the current <code>acting_user</code> are automatically made on the initial page load.  This behavior can be turned off with the <code>auto_connect</code> option.</p>
<pre class="highlight ruby"><code><span class="k">class</span> <span class="nc">TeamPolicy</span>
  <span class="c1"># Allow current users to establish connections to any teams they are</span>
  <span class="c1"># members of, but disable_auto_connect</span>
  <span class="n">regulate_instance_connections</span><span class="p">(</span><span class="ss">auto_connect: </span><span class="kp">false</span><span class="p">)</span> <span class="p">{</span> <span class="n">teams</span> <span class="p">}</span>
<span class="k">end</span>
</code></pre>
<p>Its important to consider turning off automatic connections for cases like the above where
the user is likely to be a member of many teams.  Typically the client application will
want to dynamically determine which specific teams to connect to given the current state of
the application.</p>

<h3 id="manually-connecting-to-channels">Manually Connecting to Channels</h3>

<p>Normally the client will automatically connect to the available channels when a page loads, but you can also
manually connect on the client in response to some user action like logging in, or the user deciding to
display a specific team status on their dashboard.</p>

<p>To manually connect a client use the <code>Hyperloop.connect</code> method.  </p>

<p>The <code>connect</code> method takes any number of arguments each of which is either a class, an object, a String or Array.</p>

<p>If the argument is a class then the connection will be made to the matching class channel on the server.</p>
<pre class="highlight ruby"><code><span class="c1"># connect the client to the AdminUser class channel</span>
<span class="no">Hyperloop</span><span class="p">.</span><span class="nf">connect</span><span class="p">(</span><span class="no">AdminUser</span><span class="p">)</span>
<span class="c1"># if the connection is successful the client will begin getting updates on the</span>
<span class="c1"># AdminUser class channel</span>
</code></pre>
<p>If the argument is an object then a connection will be made to the matching object on the server.</p>
<pre class="highlight ruby"><code><span class="c1"># assume current_user is an instance of class User</span>
<span class="no">Hyperloop</span><span class="p">.</span><span class="nf">connect</span><span class="p">(</span><span class="n">current_user</span><span class="p">)</span>
<span class="c1"># current_user.id is used to establish which User instance to connect to on the</span>
<span class="c1"># server</span>
</code></pre>
<p>The argument can also be a string, which matches the name of a class on the server</p>
<pre class="highlight ruby"><code><span class="no">Hyperloop</span><span class="p">.</span><span class="nf">connect</span><span class="p">(</span><span class="s1">'AdminUser'</span><span class="p">)</span>
<span class="c1"># same as AdminUser class</span>
</code></pre>
<p>or the argument can be an array with a string and the id:</p>
<pre class="highlight ruby"><code><span class="no">Hyperloop</span><span class="p">.</span><span class="nf">connect</span><span class="p">([</span><span class="s1">'User'</span><span class="p">,</span> <span class="n">current_user</span><span class="p">.</span><span class="nf">id</span><span class="p">])</span>
<span class="c1"># same as saying current_user</span>
</code></pre>
<p>You can make several connections at once as well:
<code>ruby
Hyperloop.connect(AdminUser, current_user)
</code></p>

<p>Finally falsy values are ignored.</p>

<p>You can also send <code>connect</code> directly to ActiveRecord models:</p>
<pre class="highlight ruby"><code><span class="no">AdminUser</span><span class="p">.</span><span class="nf">connect!</span>    <span class="c1"># same as Hyperloop.connect(AdminUser)</span>
<span class="n">current_user</span><span class="p">.</span><span class="nf">connect!</span> <span class="c1"># same as Hyperloop.connect(current_user)</span>
</code></pre>
<h4 id="connection-sequence-summary">Connection Sequence Summary</h4>

<p>For class connections:</p>

<ol>
<li>The client calls <code>Hyperloop.connect</code>.</li>
<li>Hyperloop sends the channel name to the server.</li>
<li>Hyperloop has its own controller which will determine the <code>acting_user</code>,</li>
<li>and call the channel&#39;s <code>regulate_class_connection</code> method.</li>
<li>If <code>regulate_class_connection</code> returns a truthy value then the connection is made,</li>
<li>otherwise a 500 error is returned.</li>
</ol>

<p>For instance connections:</p>

<ol>
<li>The process is the same but the channel name and id are sent to the server.<br></li>
<li>The Hyperloop controller will do a <code>find</code> of the id passed to get the instance,</li>
<li>and if successful <code>regulate_instance_connections</code> is called,</li>
<li>which must return an either the same instance, or an enumerable with that instance as a member.</li>
<li>Otherwise a 500 error is returned.</li>
</ol>

<p>Note that the same sequence is used for auto connections and manually invoked connections.</p>

<h4 id="disconnecting">Disconnecting</h4>

<p>Calling <code>Hyperloop.disconnect(channel)</code> or <code>channel.disconnect!</code> will disconnect from the channel.</p>

<h4 id="broadcasting-and-broadcast-policies">Broadcasting and Broadcast Policies</h4>

<p>Broadcast policies can be defined for channels using the <code>regulate_all_broadcasts</code> method, and for individual objects (typically ActiveRecord models) using the <code>regulate_broadcast</code> method.  A <code>regulate_all_broadcasts</code> policy is essentially a <code>regulate_broadcast</code> that will be run for every record that changes in the system.</p>

<p>After an ActiveRecord Model change is committed, all active class channels run their channel broadcast policies, and then the instance broadcast policy associated with the changing Model is run.  So for any change there may be multiple channel broadcast policies involved, but only one (at most) regulate_broadcast.  </p>

<p>The result is that each channel may get a filtered copy of the record which is broadcast on that channel.</p>

<p>The purpose of the policies then is to determine which channel sees what.  Each broadcast policy receives the instance of the policy which responds to the following methods</p>

<ul>
<li><code>send_all</code>: send all the attributes of the record.</li>
<li><code>send_only</code>: send only the listed attributes of the record.</li>
<li><code>send_all_but</code>: send all the attributes except the ones listed.</li>
</ul>

<p>The result of the <code>send...</code> method is then directed to the set of channels using the <code>to</code> method:</p>
<pre class="highlight ruby"><code><span class="n">policy</span><span class="p">.</span><span class="nf">send_all_but</span><span class="p">(</span><span class="ss">:password</span><span class="p">).</span><span class="nf">to</span><span class="p">(</span><span class="no">AdminUser</span><span class="p">)</span>
</code></pre>
<p>Within channel broadcast policies the channel is assumed to be the channel in question:</p>
<pre class="highlight ruby"><code><span class="k">class</span> <span class="nc">AdminUserPolicy</span>
  <span class="n">regulate_all_broadcasts</span> <span class="k">do</span> <span class="o">|</span><span class="n">policy</span><span class="o">|</span>
    <span class="n">policy</span><span class="p">.</span><span class="nf">send_all_but</span><span class="p">(</span><span class="ss">:password</span><span class="p">)</span> <span class="c1">#.to(AdminUser) is not needed.</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
<p>The <code>to</code> method can take any number of arguments:</p>

<ul>
<li>a class naming a channel,</li>
<li>an object that is instance channel,</li>
<li>an ActiveRecord collection,</li>
<li>any falsy value which will be ignored,</li>
<li>or an array that will be flattened and merged with the other arguments.</li>
</ul>

<p>The broadcast policy executes in the context of the model that has just changed, so the policy can use all the methods of that model, especially relationships.  For example:</p>
<pre class="highlight ruby"><code><span class="k">class</span> <span class="nc">Message</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Base</span>
  <span class="n">belongs_to</span> <span class="ss">:sender</span><span class="p">,</span> <span class="ss">class: </span><span class="s2">"User"</span>
  <span class="n">belongs_to</span> <span class="ss">:recipient</span><span class="p">,</span> <span class="ss">class: </span><span class="s2">"User"</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">MessagePolicy</span>
  <span class="n">regulate_broadcast</span> <span class="k">do</span> <span class="o">|</span><span class="n">policy</span><span class="o">|</span>
    <span class="c1"># send all attributes to both the sender, and recipient User instance channels</span>
    <span class="n">policy</span><span class="p">.</span><span class="nf">send_all</span><span class="p">.</span><span class="nf">to</span><span class="p">(</span><span class="n">sender</span><span class="p">,</span> <span class="n">recipient</span><span class="p">)</span>
    <span class="c1"># send all attributes to intersection</span>
    <span class="n">policy</span><span class="p">.</span><span class="nf">send_all</span><span class="p">.</span><span class="nf">to</span><span class="p">(</span><span class="n">sender</span><span class="p">.</span><span class="nf">teams</span><span class="p">.</span><span class="nf">merge</span><span class="p">(</span><span class="n">recipient</span><span class="p">.</span><span class="nf">teams</span><span class="p">))</span> <span class="k">unless</span> <span class="kp">private</span><span class="p">?</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
<p>It is possible that the same channel may be sent a record from different policies, in this case the minimum set of attributes will be sent regardless of the order of the send operations.  For example:</p>
<pre class="highlight ruby"><code><span class="n">policy</span><span class="p">.</span><span class="nf">send_all_but</span><span class="p">(</span><span class="ss">:password</span><span class="p">).</span><span class="nf">to</span><span class="p">(</span><span class="no">MyChannel</span><span class="p">)</span>
<span class="c1"># ... later</span>
<span class="n">policy</span><span class="p">.</span><span class="nf">send_all</span><span class="p">.</span><span class="nf">to</span><span class="p">(</span><span class="no">MyChannel</span><span class="p">)</span>
<span class="c1"># MyChannel gets everything but the password</span>
</code></pre>
<p>or even</p>
<pre class="highlight ruby"><code><span class="n">policy</span><span class="p">.</span><span class="nf">send_only</span><span class="p">(</span><span class="ss">:foo</span><span class="p">,</span> <span class="ss">:bar</span><span class="p">).</span><span class="nf">to</span><span class="p">(</span><span class="no">MyChannel</span><span class="p">)</span>
<span class="n">policy</span><span class="p">.</span><span class="nf">send_only</span><span class="p">(</span><span class="ss">:baz</span><span class="p">).</span><span class="nf">to</span><span class="p">(</span><span class="no">MyChannel</span><span class="p">)</span>
<span class="c1"># MyChannel gets nothing</span>
</code></pre>
<p>Keep in mind that the broadcast policies are sent a copy of the policy object so you can use helper methods in your policies. Also you can add policy specific methods to your models using
<code>class_eval</code> thus keeping policy logic out of your models.</p>

<p>So we could for example we can rewrite the above MessagePolicy like this:</p>
<pre class="highlight ruby"><code><span class="k">class</span> <span class="nc">MessagePolicy</span>
  <span class="nc">Message</span><span class="p">.</span><span class="nf">class_eval</span> <span class="k">do</span>
    <span class="n">scope</span> <span class="ss">:teams_for_policy</span><span class="p">,</span> <span class="o">-&gt;</span> <span class="p">()</span> <span class="p">{</span> <span class="n">sender</span><span class="p">.</span><span class="nf">teams</span><span class="p">.</span><span class="nf">merge</span><span class="p">(</span><span class="n">recipient</span><span class="p">.</span><span class="nf">teams</span><span class="p">)</span> <span class="p">}</span>
  <span class="k">end</span>
  <span class="k">def</span> <span class="nf">teams</span>  <span class="c1"># the obj method returns the instance being regulated</span>
    <span class="p">[</span><span class="n">obj</span><span class="p">.</span><span class="nf">sender</span><span class="p">,</span> <span class="n">obj</span><span class="p">.</span><span class="nf">recipient</span><span class="p">,</span> <span class="o">!</span><span class="n">obj</span><span class="p">.</span><span class="nf">private?</span> <span class="o">&amp;&amp;</span> <span class="n">obj</span><span class="p">.</span><span class="nf">teams_for_policy</span><span class="p">]</span>
  <span class="k">end</span>
  <span class="n">regulate_broadcast</span> <span class="p">{</span> <span class="o">|</span><span class="n">policy</span><span class="o">|</span> <span class="n">policy</span><span class="p">.</span><span class="nf">send_all</span><span class="p">.</span><span class="nf">to</span><span class="p">(</span><span class="n">policy</span><span class="p">.</span><span class="nf">teams</span><span class="p">)</span> <span class="p">}</span>
<span class="k">end</span>
</code></pre>
<h4 id="browser-initiated-change-policies">Browser Initiated Change policies</h4>

<p>To allow code in the browser to create, update or destroy a model, there must be a change access policy defined for that operation.</p>

<p>Each change access policy executes a block in the context of the record that will be accessed.  The current value of <code>acting_user</code> is also defined for the life of the block.</p>

<p>If the block returns a truthy value access will be allowed, otherwise if the block returns a falsy value or raises an exception, access will be denied.</p>

<p>In the below examples we assume that your user model responds to <code>admin?</code> but this is not built into Hyperloop.</p>
<pre class="highlight ruby"><code><span class="k">class</span> <span class="nc">TodoPolicy</span>
  <span class="c1"># allow creation to any logged in user</span>
  <span class="n">allow_create</span> <span class="p">{</span> <span class="n">acting_user</span> <span class="p">}</span>
  <span class="c1"># only allow the owner, author any any admin to update a todo</span>
  <span class="n">allow_update</span> <span class="p">{</span> <span class="n">acting_user</span> <span class="o">==</span> <span class="n">owner</span> <span class="o">||</span> <span class="n">acting_user</span> <span class="o">==</span> <span class="n">author</span> <span class="o">||</span> <span class="n">acting_user</span><span class="p">.</span><span class="nf">admin?</span> <span class="p">}</span>
  <span class="c1"># don't allow Todo's to be destroyed</span>
  <span class="c1"># this is the default behavior so its not actually needed</span>
  <span class="n">allow_destroy</span> <span class="p">{</span> <span class="kp">false</span> <span class="p">}</span>
<span class="k">end</span>
</code></pre>
<p>There are several variants of the access policy method:</p>
<pre class="highlight ruby"><code><span class="k">class</span> <span class="nc">ConfigDataPolicy</span>
  <span class="n">allow_change</span><span class="p">(</span><span class="ss">on: </span><span class="p">[</span><span class="ss">:create</span><span class="p">,</span> <span class="ss">:update</span><span class="p">,</span> <span class="ss">:destroy</span><span class="p">])</span> <span class="p">{</span> <span class="n">acting_user</span><span class="p">.</span><span class="nf">admin?</span> <span class="p">}</span>
  <span class="c1"># which can be shortened to:</span>
  <span class="n">allow_change</span> <span class="p">{</span> <span class="n">acting_user</span><span class="p">.</span><span class="nf">admin?</span> <span class="p">}</span>
<span class="k">end</span>
</code></pre><pre class="highlight ruby"><code><span class="k">class</span> <span class="nc">ApplicationPolicy</span>
  <span class="c1"># do any thing to all models unless we are in production!  Be careful!</span>
  <span class="n">allow_change</span><span class="p">(</span><span class="ss">to: :all</span><span class="p">)</span> <span class="p">{</span> <span class="kp">true</span> <span class="p">}</span> <span class="k">unless</span> <span class="no">Rails</span><span class="p">.</span><span class="nf">env</span><span class="p">.</span><span class="nf">production?</span>
  <span class="c1"># and always allow admins to destroy models globally:</span>
  <span class="n">allow_change</span><span class="p">(</span><span class="ss">to: :all</span><span class="p">,</span> <span class="ss">on: :destroy</span><span class="p">)</span> <span class="p">{</span> <span class="n">acting_user</span><span class="p">.</span><span class="nf">admin?</span> <span class="p">}</span>
  <span class="c1"># which is the same as saying:</span>
  <span class="n">allow_destroy</span><span class="p">(</span><span class="ss">to: :all</span><span class="p">)</span> <span class="p">{</span> <span class="n">acting_user</span><span class="p">.</span><span class="nf">admin?</span> <span class="p">}</span>
  <span class="c1"># you can create model specific policies in the Application Policy as well.</span>
  <span class="c1"># Here we allow the author of a message to destroy the message within 5</span>
  <span class="c1"># minutes of creation.</span>
  <span class="n">allow_destroy</span><span class="p">(</span><span class="ss">to: </span><span class="no">Message</span><span class="p">)</span> <span class="k">do</span>
    <span class="k">return</span> <span class="kp">true</span> <span class="k">if</span> <span class="n">acting_user</span> <span class="o">==</span> <span class="n">author</span> <span class="o">&amp;&amp;</span> <span class="n">created_at</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="p">.</span><span class="nf">minutes</span><span class="p">.</span><span class="nf">ago</span>
    <span class="k">return</span> <span class="kp">true</span> <span class="k">if</span> <span class="n">acting_user</span><span class="p">.</span><span class="nf">admin?</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
<p>Note that there is no <code>allow_read</code> method.  Read access is granted if this browser would have the attribute broadcast to it.  </p>

<h4 id="method-summary-and-name-space-conflicts">Method Summary and Name Space Conflicts</h4>

<p>Policy classes (and the Hyperloop::PolicyMethods module) define the following class methods:</p>

<ul>
<li><code>regulate_connection</code></li>
<li><code>regulate_all_broadcasts</code></li>
<li><code>regulate_broadcast</code></li>
</ul>

<p>As well as the following instance methods:
+ <code>send_all</code>
+ <code>send_all_but</code>
+ <code>send_only</code>
+ <code>obj</code></p>

<p>To avoid name space conflicts with your classes, Hyperloop policy classes (and the Hyperloop::PolicyMethods module) maintain class and instance <code>attr_accessor</code>s named <code>synchromesh_internal_policy_object</code>.   The above methods call methods of the same name in the appropriate internal policy object.</p>

<p>You may thus freely redefine of the class and instance methods if you have name space conflicts</p>
<pre class="highlight ruby"><code><span class="k">class</span> <span class="nc">ProductionCenterPolicy</span> <span class="o">&lt;</span> <span class="no">MyPolicyClass</span>
  <span class="c1"># MyPolicyClass already defines our version of obj</span>
  <span class="c1"># so we will call it 'this'</span>
  <span class="k">def</span> <span class="nf">this</span>
    <span class="n">synchromesh_internal_policy_object</span><span class="p">.</span><span class="nf">obj</span>
  <span class="k">end</span>
  <span class="p">.</span><span class="nf">.</span><span class="p">.</span>
<span class="nf">end</span>
</code></pre>
        </div>
      </div>
    </div>

    <div class="page-footer-upperline">
      <div class="container">

      </div>
    </div>

    <footer class="nav-footer">
  <section class="sitemap">

    <a href="/" class="nav-home"></a>

    <div>
      <h6><a href="/start/components" class="hyperloop-white">Start</a></h6>
      <a href="/start/components">Components</a>
      <a href="/start/stores">Stores</a>
      <a href="/start/models">Models</a>
      <a href="/start/operations">Operations</a>
      <a href="/start/policies">Policies</a>
      <a href="/start/pradgmatic">Pragmatic Thinking</a>
    </div>
    <div>


      <h6><a href="/tutorials" class="hyperloop-white">Tutorials</a></h6>
      <a href="/tutorials/hyperloopcomps">Hyperloop COMPS</a>
      <a href="/tutorials/hyperloopjs">Hyperloop.js</a>
      <a href="/tutorials/hyperlooprails">Hyperloop and Rails</a>
      <a href="/tutorials/hyperloopdeploy">Hyperloop deployment</a>
      <a href="/tutorials/opal">Opal</a>
      <a href="/tutorials/videos">Videos</a>
    </div>
    <div>
      <h6><a href="/installation" class="hyperloop-white">Installation</a></h6>
      <a href="/installation#opal-playground">Hyperloop.js</a>
  	  <a href="/installation#ror">With Ruby On Rails</a>
  	  <a href="/installation#with-sinatra">With Sinatra</a>
  	  <a href="/installation#deployment">Deployment</a>
    </div>
    <div>
      <h6><a href="/gems" class="hyperloop-white">Gems</a></h6>
      <a href="https://github.com/ruby-hyperloop/hyperloop">hyperloop</a>
      <a href="https://github.com/ruby-hyperloop/hyperloop-js">hyperloop-js</a>
      <a href="https://github.com/ruby-hyperloop/hyper-react">hyper-component</a>
      <a href="https://github.com/ruby-hyperloop/hyper-store">hyper-store</a>
      <a href="https://github.com/ruby-hyperloop/hyper-mesh">hyper-model</a>
      <a href="https://github.com/ruby-hyperloop/hyper-operation">hyper-operation</a>
      <a href="https://github.com/ruby-hyperloop/reactrb-router/tree/v2-4-0">hyper-router</a>
      <a href="https://github.com/ruby-hyperloop/hyper-spec">hyper-spec</a>
      <a href="https://github.com/ruby-hyperloop/hyper-trace">hyper-trace</a>
    </div>
    <div>
      <h6><a href="/tools" class="hyperloop-white">Tools</a></h6>
      <a href="#testing">Testing</a>
    	<a href="#tools">Tools</a>
    	<a href="#debugging">Debugging</a>
    </div>
    <div>
      <h6><a href="/docs/architecture" class="hyperloop-white">Docs</a></h6>
      <a href="/docs/architecture">Architecture</a>
      <a href="/docs/components/dsl-overview">Components</a>
      <a href="/docs/stores/overview">Stores</a>
      <a href="/docs/models/overview">Models</a>
      <a href="/docs/operations/overview">Operations</a>
      <a href="/docs/policies/authorization">Policies</a>
    </div>

  </section>

  <section class="otherlinks">
    <a href="https://github.com/ruby-hyperloop" class="hyperloop-white">Github</a>
    <a href="/support" class="hyperloop-white">Help</a>
    <a href="/blog" class="hyperloop-white">Blog</a>
    <a href="/showcase" class="hyperloop-white">Showcase</a>
  </section>

  <section class="copyright">
    Copyright  2017 Hyperloop.
  </section>
</footer>


    <script>
      (function(Opal) {
        var self = Opal.top, $scope = Opal, nil = Opal.nil, $breaker = Opal.breaker, $slice = Opal.slice;
        Opal.add_stubs(['$puts']);
        return self.$puts("Opal ok")
      })(Opal);
    </script>

    <!-- <script   src="http://code.jquery.com/jquery-3.1.1.min.js"   integrity="sha256-hVVnYaiADRTO2PzUGmuLJr8BLUSjGIZsDYGmIJLv2b8="   crossorigin="anonymous"></script> -->


    <script type="text/ruby">puts "Hyperloop JS ok"</script>


  </body>
</html>
